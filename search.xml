<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android架构：第三部分-在Android上应用Clean架构 (译)</title>
    <url>/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%9C%A8Android%E4%B8%8A%E5%BA%94%E7%94%A8Clean%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>到目前为止，在这个系列中，我们已经介绍了一些初学者的错误，并通过了Clean架构。 在最后一部分中，我们将介绍拼图的最后一部分：标签，或者更确切地说：组件。</p>
<p>首先，我将删除我们在Android项目中不使用的东西，然后添加一些我们使用的东西，但在原始的Bob叔叔图中找不到。 它看起来像这样：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-1.png" alt="clean architecture - 1"></p>
<p>我会从最抽象的中心走到边缘。</p>
<span id="more"></span>

<h2 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a>Entities</h2><p>Entities，即<strong>Domain 对象</strong>或业务对象，它们是App的核心。 它们代表了APP的主要功能，您应该能够通过查看它们来了解APP的功能。 它们包含业务逻辑，但仅限于它们 - 验证和类似的东西。 他们不会与外在世界的细节进行互动，也不会处理持久性。 例如，如果您有新闻APP，则这些实体将是类别，文章和商业广告。</p>
<h2 id="Use-cases"><a href="#Use-cases" class="headerlink" title="Use cases"></a>Use cases</h2><p>Use case，又名interactors，又名business services，是Entities的扩展，是业务逻辑的延伸，也就是说。 它们包含的逻辑不仅限于一个实体，而是处理更多的实体。 一个好Use case的一个指标是，你可以用一种通用的语言描述它在一个简单的句子中的作用 - 例如，”从一个账户转移到另一个账户”。你甚至可以用这样的命名来命名该类，例如，TransferMoneyUseCase。</p>
<h2 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h2><p>Repositories用于坚持Entities。 就这么简单。 它们被定义为接口并用作想要对Entities执行CRUD操作的用例的输出端口。 另外，它们可以公开一些与持久性相关的更复杂的操作，例如过滤，聚合等。 具体的持久性策略，例如数据库或因特网，是在外层实现的。 例如，您可以命名接口AccountRepository。</p>
<h2 id="Presenters"><a href="#Presenters" class="headerlink" title="Presenters"></a>Presenters</h2><p>如果你熟悉MVP模式，Presenters就会做你期望他们做的事情。 他们处理用户交互，调用适当的业务逻辑，并将数据发送到UI进行渲染。 这里通常有不同类型的模型之间的映射。 有些人会在这里使用Controller，这很好。 我们使用的Presenter正式被称为监督Controller。 我们通常在每个屏幕上定义一个或两个Presenters，具体取决于屏幕，Presenter的生命周期与视图的生命周期相关联。 一条建议：尝试在Presenter上将您的方法命名为技术不可知论者（technology agnostic）。 假设您不知道视图实现的技术。因此，如果您在视图中具有名为onSubmitOrderButtonClicked和onUserListItemSelected的方法，则处理这些事件的相应演示者方法可以命名为submitOrder和selectUser。</p>
<h2 id="Device"><a href="#Device" class="headerlink" title="Device"></a>Device</h2><p>这个组件在通知（再次）例子中已经被取笑了。它包含了诸如传感器，警报，通知，播放器，各种Managers等Android提供东西的实现。它是一个由两部分组成的部分。第一部分是业务逻辑用作与外部世界进行通信的输出端口的内部圈定义的接口。第二部分，这是在图中绘制的，是这些接口的实现。因此，您可以定义例如名为Gyroscope，Alarm，Notifications和Player的接口。注意名称是抽象的和技术不可知（technology agnostic）的。业务逻辑不关心如何显示通知，玩家如何播放声音，或陀螺仪数据来自何处。您可以制作将通知写入终端，将声音数据写入日志或从预定义文件收集陀螺仪数据的实现。这样的实现对于调试或创建确定性环境是非常有用的。但是，您当然必须制作诸如AndroidAlarm，NativePlayer等实现。在大多数情况下，这些实现只是围绕Android的Manager 类的包装。</p>
<h2 id="DB-API"><a href="#DB-API" class="headerlink" title="DB &amp; API"></a>DB &amp; API</h2><p>将存储库的实现放在这个组件中。所有这些底层持久化的东西应该在这里：DAO，ORM的东西，Retrofit（或别的东西）的东西，JSON解析等。你也可以在这里实现缓存策略，或者只是使用内存中的持久性，直到完成与应用程序的其余部分。我们最近在团队中进行了一次有趣的讨论。问题是这样的：资源库是否应公开诸如fetchUsersOffline（fetchUsersFromCache）和fetchUsersOnline（fetchUsersFromInternet）之类的方法？换句话说，业务逻辑应该知道数据来自哪里？看过这篇文章的所有内容后，答案很简单：不。但是有一个问题！如果关于数据源的决定是业务逻辑的一部分 - 例如，如果用户可以选择它，或者如果您有明确的离线模式的应用程序，那么您可以添加这样的区别。但是我不会为每个抓取定义两种方法。我可能会在资源库中公开方法，如enterOfflineMode和exitOfflineMode。或者，如果它适用于所有存储库，则可以使用输入和退出方法定义OfflineMode接口，并在业务逻辑端使用它，让存储库查询该模式并在内部进行确定。</p>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>将与Android用户界面相关的所有内容放在这里 Activities，fragments，views，adapters等完成。</p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>下图显示了我们如何将所有这些组件分成Android Studio模块。 你可能会发现另一个更合适的部门。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-2.png" alt="clean architecture - 2"></p>
<p>我们将entities，use cases，repositories和device接口分组到domain模块中。 如果您想获得额外的挑战，并获得永恒的荣耀和完全干净的设计，您可以使该模块成为纯Java模块。 它会阻止你在这里使用快捷方式并将相关的东西放在Android上。</p>
<p>device模块应该包含与Android相关的所有内容，而不是数据持久性和UI。 正如我们已经说过的，data模块应该包含与数据持久性相关的所有内容。 你不能让这两个人进入Java模块，因为他们需要访问各种Android的东西。 你可以将它们变成Android库。</p>
<p>最后，我们将与UI相关的所有内容（包括presenters）分组到UI模块中。 您可以明确地命名为UI，但由于Android中的所有东西，我们将其命名为”app”，就像Android Studio在创建项目时命名的那样。</p>
<h2 id="这样更好些了吗？"><a href="#这样更好些了吗？" class="headerlink" title="这样更好些了吗？"></a>这样更好些了吗？</h2><p>为了回答这个问题，我会抛弃Bob叔叔的图表，并将之前描述的组件扩展到像我们用来评估以前类型的体系结构的图表。 这样做后，我们得到这个：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-3.png" alt="clean architecture - 3"></p>
<p>现在让我们应用我们在以前的体系结构中使用的相同条件。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-4.png" alt="clean architecture - 4"></p>
<p>它完全由模块级别，封装级别和类级别分开。 所以SRP应该得到满足。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-5.png" alt="clean architecture - 5"></p>
<p>我们尽可能将Android和现实世界推到了最外面。 业务逻辑不再直接接触Android。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-6.png" alt="clean architecture - 6"></p>
<p>我们有很好的分离类，很容易测试。 接触世界的类可以使用Android测试用例进行测试; 可以使用JUnit测试它。 有人恶意可能会称这类爆炸。 我称之为可测试的。:)</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-7.png" alt="clean architecture - 7"></p>
<h2 id="Clean架构：它可能很复杂-但它是值得的"><a href="#Clean架构：它可能很复杂-但它是值得的" class="headerlink" title="Clean架构：它可能很复杂 - 但它是值得的"></a>Clean架构：它可能很复杂 - 但它是值得的</h2><p>我希望我精心挑选的标准并不是为了支持Clean架构而编造的，它会让你尝试一下。 这看起来很复杂，而且这里有很多细节，<strong>但它是值得的。</strong> 一旦你将所有东西连接起来，测试就容易得多，错误更容易隔离，新特性易于添加，代码更具可读性和可维护性，一切正常，世界满意。</p>
<p>所以，就是这样。 如果您还没有这样做，请查看以前的系列文章：<a href="/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%AF%8F%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%E9%83%BD%E5%BE%88%E8%89%B0%E9%9A%BE-%E8%AF%91/">Mistakes</a> 和 <a href="/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-The-clean-architecture-%E8%AF%91/">Clean Architecture</a>。 如果您有任何意见或问题，请在下面留言。 我们总是有兴趣听到你的想法。</p>
<p><span class="exturl" data-url="aHR0cDovL2ZpdmUuYWdlbmN5L2FuZHJvaWQtYXJjaGl0ZWN0dXJlLXBhcnQtNC1hcHBseWluZy1jbGVhbi1hcmNoaXRlY3R1cmUtb24tYW5kcm9pZC1oYW5kcy1vbi8=">阅读我们的Android Architecture系列的第四部分<i class="fa fa-external-link-alt"></i></span>。</p>
<p>您还可以查看其他部分：</p>
<p><span class="exturl" data-url="aHR0cDovL2ZpdmUuYWdlbmN5L2FuZHJvaWQtYXJjaGl0ZWN0dXJlLXBhcnQtNS10ZXN0LWNsZWFuLWFyY2hpdGVjdHVyZS8=">Part 5: How to Test Clean Architecture<i class="fa fa-external-link-alt"></i></span></p>
<p><a href="/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-The-clean-architecture-%E8%AF%91/">Part 2: The Clean Architecture</a></p>
<p><a href="/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%AF%8F%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%E9%83%BD%E5%BE%88%E8%89%B0%E9%9A%BE-%E8%AF%91/">Part 1: every new beginning is hard</a> </p>
]]></content>
      <categories>
        <category>Android架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Clean架构</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>Android架构：第一部分-每个新的开始都很艰难 (译)</title>
    <url>/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%AF%8F%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%E9%83%BD%E5%BE%88%E8%89%B0%E9%9A%BE-%E8%AF%91/</url>
    <content><![CDATA[<p>本系列文章的目标是概述我们与Android应用程序体系结构（Android体系结构）的斗争。我意识到，无论Android应用程序架构的实施可能会如此痛苦，事实证明，这是我一直在努力的每一个优秀应用程序的基础。</p>
<p>每项技术都有其自然演变。或者更准确地说，它的社区经历了进化过程。早期采用新计算机语言或框架的用户只是希望掌握技术并尽快完成一些工作。通常情况下，新社区很小，开发人员之间知识转移的潜力有限，也就是说，由于没有可用的架构指导原则，每个人都从自己的错误中学习。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Illustration_1.png" alt="Android architecture part 1"></p>
<p>早期的Android并不例外。这对开发人员来说既酷又有吸引力，它为早期采用者成为围绕这一快速发展技术的社区的一部分提供了机会。</p>
<span id="more"></span>

<h2 id="早期Android时代的痛点：谷歌是否关心？"><a href="#早期Android时代的痛点：谷歌是否关心？" class="headerlink" title="早期Android时代的痛点：谷歌是否关心？"></a>早期Android时代的痛点：谷歌是否关心？</h2><p>你可以争辩说，那里有许多资深人士，他们拥有很多不同技术的经验，并且很快就会提出标准。嗯，不一定。如果这个技术背后有一个强大的公司可以赚钱，他们肯定会有自己的技术传播者，他们会传播关于这种新语言如何酷的文字，并且可以用它做很多事情，这很容易学习，扩展并满足数百万客户的需求。</p>
<p>微软经常用它的技术做到这一点。另一方面，当谷歌购买Android时，我诚实地认为他们将其视为一些其他方面的项目。如果您从一开始就一直处于Android世界，那么您必须记住Google根本不关心您的挫折感和感受。那些拥有更多经验，能力和帮助社区的意愿的家伙现在已经成为Android超级巨星或者小半神 - 例如Jake Wharton。</p>
<blockquote>
<p><em>“When Google bought Android, I honestly think they treated it just as some other side project.”</em></p>
</blockquote>
<p><img src="http://five.agency/wp-content/uploads/2016/11/xAmvxi.gif" alt="xamvxi"></p>
<p>你可以说的另一件事是你不必考虑很多关于代码的架构和组织，因为框架为你做了。Android强制你将你的屏幕显示放入Activities中，将可重复使用的屏幕材料分解成Fragments，并将后台的东西放入Services中，并使用Broadcast Receivers与其他人交谈，因此它使您的生活变得更加美好。对？<strong>没有</strong>。</p>
<p>首先，不管技术如何，都有一些很好的做法和原则。例如单一责任原则或依赖倒置原则，面向接口编程，杀死全局状态，试图谋杀所有状态等等。</p>
<p>**框架很少迫使你遵循原则。**相反，他们以最糟糕的方式违反了原则。想想Context，你必须在任何地方使用的上帝对象，各种单例，Fragments的生命周期（那是噩梦般的生活），AsyncTasks通常被错误地实现，所以他们吸食记忆，食物，水，并从您的APP中散发出来。</p>
<p>对于没有指南的年轻开发人员来说，制造怪物比制造APP简单。把它想象成一个意大利面般黑洞般的怪物-它作为一个Pastafarian神只是一个很好的选择，但作为APP并不好。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Illustration_2.png" alt="android architecture spaghetti monster"></p>
<p>最后，**技术和框架隐藏了APP的目的。**好的，这是一个Android应用程序，但是什么样的Android应用程序？新闻阅读器？音乐播放器？语言学习应用程序？天气应用？也许这是另一个待办事项清单应用程序。如果所有的东西都捆绑在框架提供的类中，那么你会说不清楚。</p>
<p>正如Robert Martin, aka Uncle Bob所说：”Your architecture should scream the purpose of the app.”更技术性地说，<strong>业务逻辑应该明确分开，并且独立于框架。</strong></p>
<h2 id="Android架构的四大黄金规则（或任何架构）"><a href="#Android架构的四大黄金规则（或任何架构）" class="headerlink" title="Android架构的四大黄金规则（或任何架构）"></a>Android架构的四大黄金规则（或任何架构）</h2><p>我希望现在很清楚，**您不能依赖框架来使您的代码整齐有序，特别是在Android里。**在FIve里，我们很早就意识到这一点，但缺乏立即提出核心的经验。失败真正显示出来需要很长时间，并且在项目中间无法更改整个架构。你也无法花时间将旧项目重构为新的酷炫的梦寐以求的最佳架构。所以，我们采取了渐进式的方法，**逐渐从项目到项目逐步构建我们的架构，并从错误中学习。**我们认为我们的架构应该满足几个目标，我们可以将我们的方法与这些目标进行比较。<strong>良好的架构应该做到以下几点：</strong></p>
<ol>
<li>Satisfy a multitude of stakeholders.（满足各方利益者）</li>
<li>Encourage separation of concerns.（鼓励的关注点分离）</li>
<li>Run away from the real world (Android, DB, Internet…).</li>
<li>Enable your components to be testable.（使您的组件成为可测试的）</li>
</ol>
<h3 id="I-Satisfy-a-multitude-of-stakeholders-满足各方利益者"><a href="#I-Satisfy-a-multitude-of-stakeholders-满足各方利益者" class="headerlink" title="I. Satisfy a multitude of stakeholders.(满足各方利益者)"></a>I. Satisfy a multitude of stakeholders.(满足各方利益者)</h3><p><strong>Stakeholder</strong>（在这篇文章中）是任何对你的APP感兴趣的人。除开发者外，还有UI设计师，UX设计师，PM，DB管理员，QA等。</p>
<p>当然，你不能以某种方式组织代码，例如，UX设计人员可以立即打开项目并理解所有内容，甚至可以进行一些更改。这是一个独角兽。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Illustration_3.png" alt="Android Architecture stakeholders"></p>
<p>我的意思是，你可以组织你的代码，使得当前与UX设计师一起工作的开发人员只能管理与UX相关的东西。所以，<strong>所有的交互都在classes &#x2F; modules &#x2F; components &#x2F;中分开</strong>，就算他们的工作是交互作用。而且特定的开发人员只在应用的UX部分工作时在这些组件上工作。</p>
<h3 id="II-Encourage-separation-of-concerns-（鼓励的关注点分离）"><a href="#II-Encourage-separation-of-concerns-（鼓励的关注点分离）" class="headerlink" title="II. Encourage separation of concerns.（鼓励的关注点分离）"></a>II. Encourage separation of concerns.（鼓励的关注点分离）</h3><p>我之前所说的是一个<strong>关注点分离</strong>的例子。我们鼓励这种特殊的方法，因为它可以很好地映射到团队和项目阶段的组织，但是您的架构也应该鼓励<strong>常规分离关注点</strong>。分离问题或单一职责原则说，<strong>每个组件都应该只有一个理由需要改变。</strong></p>
<h3 id="III-Run-away-from-the-real-world-Android-DB-Internet…"><a href="#III-Run-away-from-the-real-world-Android-DB-Internet…" class="headerlink" title="III. Run away from the real world (Android, DB, Internet…)."></a>III. Run away from the real world (Android, DB, Internet…).</h3><p>从现实世界中逃脱出来的这个特殊点已经在之前提到过了。我们已经说过，我们想要表现APP真正的功能而已。我们想要强调业务逻辑，并在框架下留下框架细节。这一点应该更加强烈：我们不仅要隐藏框架细节，还要隐藏与外部世界相关的所有细节。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Illustration_4.png" alt="Android Architecture under the hood"></p>
<p>基本所有的Android的东西如传感器，通知机制，屏幕细节，数据库访问，Internet访问等等都是<strong>nitty gritty dirty</strong>。</p>
<h3 id="IV-Enable-your-components-to-be-testable"><a href="#IV-Enable-your-components-to-be-testable" class="headerlink" title="IV. Enable your components to be testable."></a>IV. Enable your components to be testable.</h3><p>您应该尽可能单元测试您的APP，并且您的架构应该允许您执行此操作。如果你不能单元测试一切，你至少应该用测试来覆盖你的业务逻辑。与现实世界的分离与此相得益彰。如果它明显与应用程序的其他部分分离，则测试业务逻辑会更容易。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/giphy-5.gif" alt="giphy-5"></p>
<h2 id="第一次迭代-上帝的活动"><a href="#第一次迭代-上帝的活动" class="headerlink" title="第一次迭代 - 上帝的活动"></a>第一次迭代 - 上帝的活动</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">UsersActivity</span> <span class="keyword">extends</span> <span class="title class_">ListActivity</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">ListUsers</span>().execute();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ListUsers</span> <span class="keyword">extends</span> <span class="title class_">AsyncTask</span>&lt;Void, Void, Void&gt; &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> Void <span class="title function_">doInBackground</span><span class="params">(Void... voids)</span> &#123;</span><br><span class="line">           <span class="comment">// final SQLiteOpenHelper sqLiteOpenHelper = ...</span></span><br><span class="line">           <span class="comment">// JsonObjectRequest jsObjRequest = new JsonObjectRequest</span></span><br><span class="line">           <span class="comment">// (Request.Method.GET, url, null, new Response.Listener&lt;JSONObject&gt;() &#123;</span></span><br><span class="line">           <span class="comment">// MySingleton.getInstance(this).addToRequestQueue(jsObjRequest);</span></span><br><span class="line">           <span class="comment">// showData(user);</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能在”古代时代”看到过类似的代码。如果你还没有，那么你还很年轻。这有什么问题？<strong>Everything!</strong></p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/no.gif" alt="no"></p>
<p>我们有一个涉及数据库，进入互联网，解析，产生线程和呈现数据的Activity。所以，<strong>所有的利益相关者都在关注单个类，没有任何问题是分离的，它不是可测试的，业务逻辑与Android的东西混杂在一起。</strong></p>
<p><img src="http://five.agency/2017/wp-content/uploads/2016/11/Diagram_1-1.png" alt="android architecture part 1 - 1"></p>
<h2 id="第二次迭代-MVP"><a href="#第二次迭代-MVP" class="headerlink" title="第二次迭代 - MVP"></a>第二次迭代 - MVP</h2><p>第一种方法显然不起作用。我们尝试的第一件事情之一是MVP，或<strong>model-view-presenter</strong>。每个人都熟悉MVP。它是最受欢迎的架构之一。它看起来像这样：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Diagram_1-1.png" alt="android architecture part 2 - 2"></p>
<p>在这里，我们分离了实际上是我们的Android Fragments的视图，我们有代表我们业务的（domain）模型，最后我们有协调所有这些的presenters。肯定会更好。关注点有些分离，利益相关者不再困惑，你可以写一些测试。然而，我们仍然与现实世界混淆，因为presenter直接触及数据库和所有内容。这是一个神的对象。它处理模型，它将数据发送到视图，它拥有业务逻辑（业务逻辑是那些齿轮:)），并且它传递到数据库和Internet，获取传感器数据等等。所以，更好，但是它可以变得更好。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Diagram_2-1.png" alt="android architecture part 1 - 3"></p>
<h2 id="第三次迭代-MVP-managers"><a href="#第三次迭代-MVP-managers" class="headerlink" title="第三次迭代 - MVP + managers"></a>第三次迭代 - MVP + managers</h2><p>当政府不知道该做什么时，他们做了什么？它设置一个机构。当开发者不知道该怎么做时，他们会做什么？他们采用一些managers。您不必将其命名为”manager”。这些类有很多名称：utils，helper，fooBarBuzz-ator等等。我们统称为managers。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Diagram_3-3.png" alt="android architecture part 1 - 4"></p>
<p>说实话，**这甚至有点奏效。**业务逻辑包含在manager类中。利益相关者知道在哪里看，关注是分开的，但他们可能更多，你可以编写更多的测试，但你仍然直接触摸Android，所以你必须编写Android测试用例和预填充数据库来测试业务逻辑，这很慢。是的，managers往往是巨大的野兽，**很快就很难维持。**你可以争辩说，它不需要比现在更复杂，你可以通过使用更简单的架构来更快地传递代码，但是这种方法会出现更多的错误，并且可维护性会受到影响。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Diagram_4-1.png" alt="android architecture part 1 - 5"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本系列的第一部分中，我们遇到了创建实际可行的Android体系结构的挑战。良好的Android架构应该满足众多利益相关者的需求，鼓励分离问题，强调业务逻辑，并将框架细节置于隐患之下，并使所有组件都可测试。在系列的第二部分中，我们将向您展示我们如何管理那些对我们有用的东西。在此之前，<strong>您对如何创建适当的Android工作流程有任何建议吗？你遇到了什么问题？</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2ZpdmUuYWdlbmN5L2FuZHJvaWQtYXJjaGl0ZWN0dXJlLXBhcnQtMi1jbGVhbi1hcmNoaXRlY3R1cmUv">Continue to part 2<i class="fa fa-external-link-alt"></i></span>.</p>
<p>您还可以查看其他部分：</p>
<p><span class="exturl" data-url="aHR0cDovL2ZpdmUuYWdlbmN5L2FuZHJvaWQtYXJjaGl0ZWN0dXJlLXBhcnQtNS10ZXN0LWNsZWFuLWFyY2hpdGVjdHVyZS8=">Part 5: How to Test Clean Architecture<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2ZpdmUuYWdlbmN5L2FuZHJvaWQtYXJjaGl0ZWN0dXJlLXBhcnQtNC1hcHBseWluZy1jbGVhbi1hcmNoaXRlY3R1cmUtb24tYW5kcm9pZC1oYW5kcy1vbi8=">Part 4: Applying Clean Architecture on Android (Hands-on)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2ZpdmUuYWdlbmN5L2FuZHJvaWQtYXJjaGl0ZWN0dXJlLXBhcnQtMy1hcHBseWluZy1jbGVhbi1hcmNoaXRlY3R1cmUtYW5kcm9pZC8=">Part 3: Applying Clean Architecture on Android<i class="fa fa-external-link-alt"></i></span> </p>
]]></content>
      <categories>
        <category>Android架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Clean架构</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>Android架构：第二部分-The clean architecture (译)</title>
    <url>/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-The-clean-architecture-%E8%AF%91/</url>
    <content><![CDATA[<p>在系列的第一部分中，我们介绍了我们在寻找可行的体系结构方面所犯的错误。 在这一部分中，我们将介绍所谓的<strong>Clean Architecture</strong>.</p>
<p>你在google”clean architecture”中遇到的第一个图像是这样的：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-1.png" alt="the clean architecture "></p>
<p>它也被称为<strong>洋葱架构</strong>，因为图表看起来像一个洋葱（当你意识到你需要写多少样板时，它会让你哭泣）; 或端口和适配器，因为您可以看到右下角有一些端口。 <strong>六角形架构</strong>是另一种类似的架构。</p>
<p><strong>Clean architecture</strong>是前面提到的Bob叔叔的心血结晶，他也写了关于Clean Code和Clean Coder的书籍。 这种方法的主要观点是业务逻辑（也称为domain）处于宇宙的中心。</p>
<span id="more"></span>

<h2 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h2><p>当你打开你的项目，你应该已经知道这个APP是什么。 其他一切都是实现细节。 例如：持久性 - 这是一个细节。 定义一个接口，使内存实现一个快速而肮脏的实现，在业务完成之前不要考虑它。 然后，您可以决定如何确实坚持数据。 数据库，互联网，组合，文件系统 - 也许把它们留在内存中，也许事实证明你根本不必坚持它们。 在一句话中：内层包含业务逻辑，外层包含实现细节。</p>
<p>这就是说，有一些Clean Architecture可以实现这些功能：</p>
<ol>
<li>Dependency rule（依赖规则）</li>
<li>Abstraction（抽象）</li>
<li>Communication between layers（层之间的通信）</li>
</ol>
<h2 id="I-Dependency-rule（依赖规则）"><a href="#I-Dependency-rule（依赖规则）" class="headerlink" title="I. Dependency rule（依赖规则）"></a>I. Dependency rule（依赖规则）</h2><p>依赖关系规则可以用下图来解释：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-2.png" alt="graph-2"></p>
<p>外层应该取决于内层。 红色方块中的这三个箭头表示相关性。 “依赖”也许这是最好用的术语，如”看”，”知道”，或者”知道的。”没那么好。在这方面，外层看到并了解内层，但内层既不看也不知道外层。 如前所述，内层包含业务逻辑，外层包含实现细节。 结合依赖关系规则，业务逻辑既看不到，也不知道实现细节。 这正是我们正在努力完成的。</p>
<p>您如何实现依赖关系规则取决于您。 您可以将它放在不同的包中，但要小心不要使用”内部”包装中的”外层”包装。 但是，如果有人没有意识到依赖性原则，没有什么能阻止他们打破它。 例如，更好的方法是将图层分成不同的Android模块，并调整构建文件中的依赖关系，以便内层无法使用外层。 在Five，我们使用了两者之间的东西。</p>
<p>值得一提的是，尽管没有人可以阻止你跳过图层 ，例如，在蓝色图层组件中使用红色图层组件。我强烈建议您仅访问图层旁边的组件。</p>
<h2 id="II-Abstraction（抽象）"><a href="#II-Abstraction（抽象）" class="headerlink" title="II. Abstraction（抽象）"></a>II. Abstraction（抽象）</h2><p><strong>抽象原则</strong>已经暗示过。 当你走向图的中间时，东西变得更加抽象。 这是有道理的：正如我们所说的内圈包含业务逻辑，外圈包含实现细节。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-3.png" alt="clean android architecture "></p>
<p>您甚至可以在多个图层之间划分相同的逻辑组件，如上图所示： 在内层中可以定义更抽象的部分，外层中更具体的部分。</p>
<p>一个例子会说清楚：我们可以将抽象接口定义为”通知”并将其放入内层，这样，您的业务逻辑就可以使用它来向用户显示通知。 另一方面，我们可以通过实现使用Android通知管理器显示通知的方式来实现该接口，然后将该实现放入外层。</p>
<p>通过这种方式，业务逻辑可以在我们的示例中使用功能通知 - 但它不知道实现细节的任何内容：实际通知是如何实现的。 而且，业务逻辑甚至不知道实现细节存在。 看看下面的图片：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-4.png" alt="clean android architecture"></p>
<p>将抽象与依赖规则结合起来时，事实证明，使用通知的抽象业务逻辑既没有看到也没有意识到使用Android通知管理器的具体实现。 这很好，因为我们可以切换具体实现，业务逻辑甚至不会注意到它。</p>
<p>让我们简单地比较一下使用标准三层体系结构时抽象和依赖关系的外观和工作方式。</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-5.png" alt="graph-5"></p>
<p>您可以在图中看到标准三层体系结构中的所有依赖关系都转到数据库。 这意味着抽象和依赖不匹配。 从逻辑上讲，业务层应该是应用程序的中心，但不是，因为依赖关系会转向数据库。</p>
<p>业务层不应该知道数据库。 而在清洁架构中，依赖关系转到业务层（内层），而抽象层也向业务层上升，因此它们匹配得很好。</p>
<p>这很重要，因为抽象是理论，依赖是实践。 抽象是应用程序的逻辑布局，依赖关系是它如何组合在一起。 在 clean architecture中，这两者匹配，而在标准的三层架构中则没有; 如果你不小心，这可能会很快导致各种逻辑不一致和混乱。</p>
<h2 id="III-Communication-between-layers（层之间的通信）"><a href="#III-Communication-between-layers（层之间的通信）" class="headerlink" title="III. Communication between layers（层之间的通信）"></a>III. Communication between layers（层之间的通信）</h2><p>现在我们已经将应用程序划分为模块，很好地分离了所有内容，将业务逻辑放在应用程序的中心和郊区的实现细节中，一切看起来都很棒。 但是你可能很快遇到了一个有趣的问题。</p>
<p>如果你的UI是一个实现细节，那么internet就是一个实现细节，业务逻辑介于两者之间，<strong>我们如何从internet获取数据，通过业务逻辑传递它，然后将其发送到屏幕？</strong></p>
<p>业务逻辑处于中间，应该在互联网和用户界面之间进行调解，但它甚至不知道这两个人存在。 这是一个沟通和数据流的问题。</p>
<p>我们希望数据能够从外层流向内层，反之亦然，但依赖性规则不允许这样做。 让我们将其简化为最简单的例子:</p>
<p>我们只有两层，绿色和红色。 绿色的是外在的，知道红色的，红色的是内在的，只知道自己。 我们希望数据从绿色流向红色流，然后返回绿色流。 该解决方案之前已经被暗示过，如下图所示：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-6.png" alt="clean android architecture"></p>
<p>右下角的图部分显示了数据流。 数据从Controller通过Use Case（或用用户选择的组件替换用例）输入端口，然后通过Use Case本身，然后通过Use Case输出端口返回给Presenter。</p>
<p>图的主要部分上的箭头表示组成和继承 - 组成和继承 - 组成由一个实心箭头表示，继承由一个一个空箭头表示。 组成也被称为<strong>有关系</strong>，而继承是<strong>一种关系</strong>。 圆圈中的”I”和”O”表示输入和输出端口。 可以看出，在绿色层中定义的控制器具有在红色层中定义的输入端口。 Use Case（齿轮，商业逻辑，现在不重要）是（或实现）输入端口并具有输出端口。 最后，在绿色层中定义的Presenter实际上是在红色层中定义的输出端口。</p>
<p>我们现在可以将其与数据流相匹配。 Controller有一个输入端口 - 它实际上有一个参考。 它调用一个方法，以便数据从Controller传输到输入端口。 但是输入端口是一个接口，实际的实现就是Use Case：所以它在一个Use Case上调用一个方法，数据流向Use Case。 Use Case做了一些事情，并希望将数据返回。 它有一个对输出端口的引用 - 因为输出端口是在同一层定义的 - 所以它可以调用它的方法。 因此，数据进入输出端口。 最后，Presenter是或实现输出端口; 这是神奇的一部分。 由于它实现了输出端口，数据实际上流入了它。</p>
<p>诀窍是Use Case只知道它的输出端口; 世界在这个输出端口结束。 实施它取决于Presenter， 它可能已经被任何东西实现了，因为用例不知道或关心，并且只知道其层中的小世界。 我们可以看到，通过组合和继承的组合，我们可以使数据在两个方向上流动，尽管内层不知道他们正在与外部世界进行通信。 快速浏览下图：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-7.png" alt="clean android architecture"></p>
<p>你可以看到两个箭头都指向中间，就像依赖箭头一样。 那么，这是合乎逻辑的。 根据依赖规则，这是唯一可行的方法。 外层可以看到内层，但不是其他方式。 唯一棘手的部分是，这是一种关系，虽然它指向中间，但会颠倒数据流。</p>
<p>请注意，定义其输入和输出端口是内层的责任，以便外层可以使用它们与之建立通信。 我已经说过这个解决方案已经在之前被暗示了，而且已经有了。 说明抽象的通知示例也是这种通信的一个例子。 我们在内层中定义了一个通知接口，业务逻辑可以使用它向用户显示通知，但我们也有一个在外层中定义的实现。 在这种情况下，通知接口是业务逻辑的输出端口，它用于与外部世界进行通信 - 本例中的具体实现。 您不必为您的类命名FooOutputPort或BarInputPort; 我们命名只是为了解释这个理论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么，这是过于复杂，过度模糊的过度工程？ 好吧，当你习惯它时很简单。 这是必要的。 它使我们能够在现实世界中实现良好的抽象&#x2F;依赖匹配实际交流和工作。 也许这一切都让人联想到弦理论：理论上美观，但是过于复杂，我们仍然不知道它是否有效，但在我们的案例中 - 它确实有效。:)</p>
<p>这就是这个系列的第二部分。 最后，第三部分，毕竟我们已经了解了理论和体系结构，将涵盖所有你需要了解的关于这些图表上的标签，或者换句话说 - 单独的组件。 我们将向您展示在Android上应用的真实生活Clean Architecture。</p>
<p>这是Android体系结构博客文章系列的一部分。您还可以查看其他部分：</p>
<p><span class="exturl" data-url="aHR0cDovL2ZpdmUuYWdlbmN5L2FuZHJvaWQtYXJjaGl0ZWN0dXJlLXBhcnQtNS10ZXN0LWNsZWFuLWFyY2hpdGVjdHVyZS8=">Part 5: How to Test Clean Architecture<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2ZpdmUuYWdlbmN5L2FuZHJvaWQtYXJjaGl0ZWN0dXJlLXBhcnQtNC1hcHBseWluZy1jbGVhbi1hcmNoaXRlY3R1cmUtb24tYW5kcm9pZC1oYW5kcy1vbi8=">Part 4: Applying Clean Architecture on Android (Hands-on)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2ZpdmUuYWdlbmN5L2FuZHJvaWQtYXJjaGl0ZWN0dXJlLXBhcnQtMy1hcHBseWluZy1jbGVhbi1hcmNoaXRlY3R1cmUtYW5kcm9pZC8=">Part 3: Applying Clean Architecture on Android<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2ZpdmUuYWdlbmN5L2FuZHJvaWQtYXJjaGl0ZWN0dXJlLXBhcnQtMS1ldmVyeS1uZXctYmVnaW5uaW5nLWlzLWhhcmQv">Part 1: every new beginning is hard<i class="fa fa-external-link-alt"></i></span> </p>
]]></content>
      <categories>
        <category>Android架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Clean架构</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedIn的高效代码检视建议(译)</title>
    <url>/2018/06/10/LinkedIn%E7%9A%84%E9%AB%98%E6%95%88%E4%BB%A3%E7%A0%81%E6%A3%80%E8%A7%86%E5%BB%BA%E8%AE%AE(%E8%AF%91)/</url>
    <content><![CDATA[<p>原文：LinkedIn’s Tips for Highly Effective Code Review<br>原著作者：Szczepan Faber</p>
<blockquote>
<p><em>最近LinkedIn里程碑式地完成了他们的第100万次代码检视，这篇文章是LinkedIn社交网络服务工具的负责人Szczepan Faber分享的一些经验与教训。</em></p>
</blockquote>
<span id="more"></span>

<p>阅读和检查代码是每个工程师每天都在做的事情，然而正式的代码检视流程会有点不一样（它要求在代码上线之前），每个代码的更改都要由其他团队成员进行正式检视。在LinkedIn上，自2011年以来，代码检视一直是我们开发流程的强制性部分。我们要求代码检视的目标是尽可能顺利地扩展我们快速发展的工程团队。良好的代码检视与有意义的有用评论确实可以帮助提升整个工程组织。在LinkedIn，这些检视已成为质量保证和知识共享的重要组成部分。拥抱代码检视已经在几个关键方面优化了我们整个工程文化。</p>
<p>实施全公司代码检视的最大好处之一是增加了我们开发工作流程的标准化。LinkedIn上的每个团队都使用相同的工具和流程来进行代码检视，这意味着任何人都可以帮助审核或为其他团队的项目提供代码。这消除了”我可以修复代码中的错误，但是我将如何构建该代码并提交修复？”这样可以帮助增加工程组织中不同团队之间的协作。</p>
<p>通过将代码检视制定为强制性流程，我们还帮助培养了公司健康的反馈文化：工程师们对所有工作领域都给予反馈并接受反馈，而不仅仅是编码，因为它已成为工作的常规组成部分。我们的工程师不是将代码检视视为关键或否定，而是将代码审查和代码评论作为专业发展的机会。事实上，高质量的代码审查是LinkedIn推广流程的重要组成部分，因为它们提供了工程技术的客观证据。</p>
<p>多年来，我们磨练了几个最佳实践和技巧，以便如何提供真正的优秀代码检视。以下是一些以问题形式提供的指南，我们建议您通过这些指南来帮助确保审阅者和被审阅者都从代码检视中获得最大价值。</p>
<h3 id="我了解「为什么」吗？"><a href="#我了解「为什么」吗？" class="headerlink" title="我了解「为什么」吗？"></a>我了解「为什么」吗？</h3><p>为了尽可能提供最佳评审和帮助您的团队进行扩展，每一次代码更改提交都应包含一个设计概述，以简要说明变更背后的动机。当需要从代码更改本身推断出理由时，提供高质量的代码检视非常困难。提出问题并期望提交者在尝试代码检视之前解释他们的动机是公平的。这也鼓励提交者在他们的提交消息中有一个解释，提高代码文档的质量。</p>
<h3 id="我是否给予积极的反馈？"><a href="#我是否给予积极的反馈？" class="headerlink" title="我是否给予积极的反馈？"></a>我是否给予积极的反馈？</h3><p>在一个充满聪明人的组织中，干净的代码和整洁的测试覆盖率可以被认为是理所当然的。因此，代码检视反馈倾向于只关注代码中发现的问题与代码本身。这是非常不幸的，因为大多数人需要积极的反馈来感受参与和动力「工程师也不例外」。 当审阅者在代码中看到好东西时，他们应该将其发出并给出正面的反馈。 这有助于改善团队动态，而且这种积极的反馈往往具有传染性。正如所有的代码检视建议（下面的更多内容）一样，任何积极的反馈都应该是具体的，解释为什么那些特定的代码是写得很好的。</p>
<h3 id="我的代码检视评论阐述得好吗？"><a href="#我的代码检视评论阐述得好吗？" class="headerlink" title="我的代码检视评论阐述得好吗？"></a>我的代码检视评论阐述得好吗？</h3><p>无论反馈是正面还是负面，任何代码检视评论都应该是不言自明的。对于收到解释不好的代码检视评论的工程师而言，对于评审者来说看起来很明显的东西可能并不清楚。如果有疑问，最好是过度解释，而不是提供简洁的反馈，这会产生更多的问题，并需要更多的来回通信。建议可以像”减少重复”，”提高覆盖率”或”使代码更容易测试”一样简单。除了使审阅者的评论更加清晰之外，这些类型的评论还有助于加强团队渴望满足的设计原则。</p>
<h3 id="我表扬了提交者的努力吗？"><a href="#我表扬了提交者的努力吗？" class="headerlink" title="我表扬了提交者的努力吗？"></a>我表扬了提交者的努力吗？</h3><p>无论结果如何，艰苦的工作总是需要被表扬 - 这培养了强有力的，充满活力的团队。一些代码如果改不到最高质量的话，就需要重新设计。 在这些情况下，即使他们的代码的确需要重新设计，仍然承认作者对变更所做的努力是很重要的。表现欣赏的最佳方式是通过提供高质量的反馈并提供合适的解释，承认好的想法（每次提交代码总是有好的东西！）并使用”谢谢”来投入您的代码检视。</p>
<h3 id="这篇检视评论对我有用吗？"><a href="#这篇检视评论对我有用吗？" class="headerlink" title="这篇检视评论对我有用吗？"></a>这篇检视评论对我有用吗？</h3><p>提出这个问题是验证代码检视评论是否必要的简单而强大的方法。在一天结束时，工程师应该将代码评论视为有用的开发工具，而不是不重要的繁忙工作的来源。如果您不认为特定的检视评论对您有用，请将其删除。无用的代码检视注释的典型例子是与代码格式相关的代码。代码样式和格式应该由自动化工具验证，而不是由工程师来验证。</p>
<h3 id="只要”测试完成”就足够了吗？"><a href="#只要”测试完成”就足够了吗？" class="headerlink" title="只要”测试完成”就足够了吗？"></a>只要”测试完成”就足够了吗？</h3><p>在LinkedIn上，每个代码更改提交都有一个必须填写的强制性”已完成测试”部分。 在开源世界中，使用GitHub作为示例，工程师可以在请求描述中提交”测试完成”信息。”测试完成”应该取决于变化的严重程度和当前的测试覆盖水平。如果更改包含新的或更改的条件复杂度，则期望在单元测试中涵盖它是公平的。如果集成测试覆盖率不足，某些更改可能需要运行手动测试。 在这些情况下，”完成测试”应包括有关测试场景和输出的信息。当更换改变程序的输出时，将新输出包含在”测试完成”部分非常有用。</p>
<h3 id="我在我的检视中过于迂腐吗？"><a href="#我在我的检视中过于迂腐吗？" class="headerlink" title="我在我的检视中过于迂腐吗？"></a>我在我的检视中过于迂腐吗？</h3><p>一些代码检视有很多评论，所以导致重要的问题（真正需要修正的）在重要的建议中丢失了。 对于某个团队的详细信息而言，评论太多可能会减慢审阅周期，并且会导致审阅者和被审阅者都产生摩擦。 具有清晰的审查预期，示例评审以及积极的邀请审阅文化是避免漫长而耗尽审阅周期的好方法。</p>
<p>总之，通过正式的代码检视流程有助于提高代码质量，团队学习和知识共享。当团队中的每位工程师都意识到两件重要的事情时，工作质量会提高：其他人会阅读我的代码，我必须处理我收到的任何评论意见，所以我应该尝试让我的代码最好是好的，能够一次把事情做好是最好的。当代码检视成为日常习惯时，团队每天都会实践并提供反馈。 这是增长和改善的关键。</p>
<p>在LinkedIn，我们从过去的一百万次代码检视中学到了很多东西，并且我们渴望从下一个百万人中学到更多。代码检视中付出的努力越多，团队获得优质代码检视的能力越强，检视的代码质量越高，并且所生成产品的质量越高。 高质量的代码检视具有传染性！ </p>
]]></content>
      <categories>
        <category>团队建设</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>CodeReview</tag>
      </tags>
  </entry>
  <entry>
    <title>RxAndroid新型异步API（译）</title>
    <url>/2018/09/02/RxAndroid%E6%96%B0%E5%9E%8B%E5%BC%82%E6%AD%A5API%EF%BC%88%E8%AF%91%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：RxAndroid’s New Async API</p>
<p>原文作者：Zac Sweers</p>
<p>译文出自：Dimon’s Program Basement</p>
<p>译者：Dimon</p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*VMZbrxTyr3ga00M0mjNwyw.png" alt="RxAndroid"></p>
<h3 id="RxAndroid-2-1-0有一个新的API："><a href="#RxAndroid-2-1-0有一个新的API：" class="headerlink" title="RxAndroid 2.1.0有一个新的API："></a>RxAndroid 2.1.0有一个新的API：</h3><blockquote>
<p>AndroidSchedulers#from(Looper looper, <strong>boolean async</strong>)</p>
</blockquote>
<p>这新的<code>async</code>参数将影响Android APIs 16 及其以上版本，如果你的APP高度依赖RxJava+RxAndroid，将这个参数设置为<code>true</code>将能够<strong>显著提升 UI 性能</strong>表现。</p>
<span id="more"></span>

<p>由于RxAndroid的主要版本与RxJava绑定，我们不希望在次要版本中默默地引入重要的行为更改，所以这个API默认不启用。</p>
<p>要安装它，你可以使用<code>RxAndroidPlugins</code>设置此API自定义的<code>scheduler</code>：</p>
<blockquote>
<p>EDIT：由于类加载问题，以下代码在<code>setInitMainThreadSchedulerHandler</code>上有一些错误。为了避免初始化默认值，你应该在传入的 lambda&#x2F;callable **中(inside)**调用<code>AndroidSchedulers.from(...)</code>，而不是在之前就调用；</p>
</blockquote>
<h4 id="Kotlin："><a href="#Kotlin：" class="headerlink" title="Kotlin："></a>Kotlin：</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Before</span></span><br><span class="line"><span class="keyword">val</span> asyncMainThreadScheduler = AndroidSchedulers.from(Looper.getMainLooper(), <span class="literal">true</span>)</span><br><span class="line">RxAndroidPlugins.setInitMainThreadSchedulerHandler &#123; asyncMainThreadScheduler &#125;</span><br><span class="line"><span class="comment">//Or if the default scheduler is already initialiazed</span></span><br><span class="line">RxAndroidPlugins.setMainThreadSchedulerHandler &#123; asyncMainThreadScheduler &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Correct usage</span></span><br><span class="line">RxAndroidPlugins.setInitMainThreadSchedulerHandler &#123;</span><br><span class="line">    AndroidSchedulers.from(Looper.getMainLooper(), <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Or if the default scheduler is already initialiazed</span></span><br><span class="line">RxAndroidPlugins.setMainThreadSchedulerHandler &#123;</span><br><span class="line">    AndroidSchedulers.from(Looper.getMainLooper(), <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java："><a href="#Java：" class="headerlink" title="Java："></a>Java：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Before</span></span><br><span class="line"><span class="type">Scheduler</span> <span class="variable">asyncMainThreadScheduler</span> <span class="operator">=</span> AndroidSchedulers.from(Looper.getMainLooper(), <span class="literal">true</span>);</span><br><span class="line">RxAndroidPlugins.setInitMainThreadSchedulerHandler(callable -&gt; asyncMainThreadScheduler);</span><br><span class="line"><span class="comment">//Or if the default scheduler is already initialiazed</span></span><br><span class="line">RxAndroidPlugins.setMainThreadSchedulerHandler(scheduler -&gt; asyncMainThreadScheduler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Correct usage</span></span><br><span class="line">RxAndroidPlugins.setInitMainThreadSchedulerHandler(callable -&gt; &#123;</span><br><span class="line">    <span class="type">Scheduler</span> <span class="variable">asyncMainThreadScheduler</span> <span class="operator">=</span> AndroidSchedulers.from(Looper.getMainLooper(), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> asyncMainThreadScheduler;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Or if the default scheduler is already initialiazed</span></span><br><span class="line">RxAndroidPlugins.setMainThreadSchedulerHandler(scheduler -&gt; &#123;</span><br><span class="line">    <span class="type">Scheduler</span> <span class="variable">asyncMainThreadScheduler</span> <span class="operator">=</span> AndroidSchedulers.from(Looper.getMainLooper(), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> asyncMainThreadScheduler;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>这是一个很长的时间。RxAndroid中使用主线程历来都是使用<code>Handler#post()</code>去调度新的<code>Message</code>们。这通常是需要付出代价：默认情况下这个的遵循VSYNC锁定并且将导致<strong>等待</strong>直到下一帧运行。对于通过<code>post()</code>的每一个发射，这都将是一个高达16ms的延迟。如果你已经在主线程上，这更是会加剧这种情况的发生（Ray Ryan曾经在一个出色的演讲上讲到过这个问题)。</p>
<p>因此，在2015年，在Jake Wharton的RxBinding项目中围绕”快速路径(fastpath)”展开了讨论：主线程调度程序如果已经在主线程上并且避免VSYNC成本，则可以立即运行工作。之后这个讨论转移到RxAndroid的一个提案上，并且得到了很好的社区反馈，但是由于担心可能通过直接运行事件和冒着死锁的风险来竞争系统的事件，导致从未达成过共识；所以它受到了抨击，但对于使用者们仍旧是一个摩擦点，并且在RxAndroid2.x中提交了几个issues；</p>
<p>很快到了2017年年初，在Uber里我们决定尝试在内部进行re-hash，并且发现它_基本上_是稳定的。我们确实时而会看到死锁，但它们很难被发现，并且看起来很罕见，值得我们换取性能上的提升。上线一年后，我们决定尝试上游化我们的实现，并且重新开启讨论。这一次，Android框架工程师（Adam Powell）看到了这个讨论，并且指出我们使用<code>Message</code>和<code>Handler</code>的异步API。这个API允许消息绕过VSYNC锁定，同时仍让框架在其looper中安全地处理所有调度，这正是我们一直想要的！</p>
<h3 id="连线API"><a href="#连线API" class="headerlink" title="连线API"></a>连线API</h3><p>虽然异步API自API 16以来就已存在，但它们已经通过@hide隐藏在SDK中。在API22中，Message#setAsynchronous()方法变成了public。在API28中，有一个新的<code>Handler.createAsync（）</code>工厂API，它默认将它处理的所有消息设置为异步。由于这些API为操作系统中一些最关键的部分提供了动力，因此它们不太可能被更改，并且应该可以安全访问。这里有点乐趣。</p>
<h4 id="API-22"><a href="#API-22" class="headerlink" title="API 22+"></a>API 22+</h4><p>使用上述公共<code>setAsynchronous（）</code>方法。</p>
<h4 id="API-16-21"><a href="#API-16-21" class="headerlink" title="API[16-21]"></a>API[16-21]</h4><p>仍然使用<code>setAsynchronous（）</code>，但我们抑制了lint错误，表明它只有22+。为了避免删除&#x2F;更改内部API的任何（不太可能的）OEM情况，我们 try&#x2F;catch <code>from（）</code>调度程序工厂中的快速<code>Message＃setAsynchronous（）</code>方法调用，以确保它在运行时存在，捕获<code>NoSuchMethodError</code>，如果它丢失并且优雅地回到标准的非异步消息传递。它不是反射，因为我们知道这将在运行时，因为该方法确实存在于运行时。</p>
<h4 id="API-16"><a href="#API-16" class="headerlink" title="API &lt; 16"></a>API &lt; 16</h4><p>没有行为更改，因为异步API不存在，所以使用标准的非异步消息传递。</p>
<p>就是这些！我希望在使用主线程调度程序时，这可以让开发人员更加安心。请试一试并报告任何问题。 </p>
]]></content>
      <categories>
        <category>ReactiveX</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>译文</tag>
        <tag>RxAndroid</tag>
      </tags>
  </entry>
  <entry>
    <title>Android架构：第五部分-Clean架构是如何测试的 (译)</title>
    <url>/2018/05/13/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-Clean%E6%9E%B6%E6%9E%84%E6%98%AF%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E7%9A%84/</url>
    <content><![CDATA[<p>你为什么要关心测试？ 像任何人一样，程序员犯错误。 我们可能会忘记我们上个月实现的边缘案例，或者我们传递一个空字符串时某些方法的行为方式。</p>
<p>在每次更改后都可以使用APP，并尝试每次可能的点击，点按，手势和方向更改，以确保一切正常。 在旋转设备时，您可能会忘记右上角的三次敲击，因此当用户执行此操作时，所有内容都会崩溃，并引发空指针异常。 用户做的很愚蠢，我们需要确保每个类都能够做到应有的功能，并且APP的每个部分都可以处理我们抛出的所有内容。</p>
<p>这就是我们编写自动化测试的原因。</p>
<span id="more"></span>

<h3 id="1-测试-Clean-架构"><a href="#1-测试-Clean-架构" class="headerlink" title="1. 测试 Clean 架构"></a>1. 测试 Clean 架构</h3><p>Clean架构完全关于可维护性和可测试性。 架构的每个部分都有一个目的。 我们只需要指定它并检查它实际上是否每次都做它的工作。</p>
<p>现在，让我们现实一点。 我们可以测试什么？ 一切。 诚然，如果你正确地构建你的代码，你可以测试一切。 这取决于你要测试什么。 不幸的是，通常没有时间来测试一切。</p>
<p>可测性。 这是第一步。 第二步是测试正确的方法。 让我们提醒一下<strong>FIRST</strong>的旧规则：</p>
<p><strong>Fast</strong> – 测试应该非常快。如果需要几分钟或几小时来执行测试，写测试是没有意义的。 没有人会检查测试，如果是这样的话！</p>
<p><strong>Isolated</strong> – 一次测试APP的一个单元。 安排在该单位的一切行为完全按照你想要的方式，然后执行测试单位并且断言它的行为是正确的。</p>
<p><strong>Repeatable</strong> – 每次执行测试时都应该有相同的结果。 它不应该依赖于一些不确定的数据。</p>
<p><strong>Self-validating</strong> – 框架应该知道测试是否通过。 不应该有任何手动检查测试。 只要检查一切是否是绿色，就是这样:)</p>
<p><strong>Timely</strong> – 测试应该和代码一样写，或者甚至在代码之前写！</p>
<p>所以，我们制作了一个可测试的APP，我们知道如何测试。 那如何命名单元测试的名字呢？</p>
<h3 id="2-命名测试"><a href="#2-命名测试" class="headerlink" title="2. 命名测试"></a>2. 命名测试</h3><p>说实话，我们如何命名测试很重要。它直接反映了你对测试的态度，以及你想要测试什么的方式。</p>
<p>让我们认识我们的受害者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DeleteFeedUseCase</span> <span class="keyword">implements</span> <span class="title class_">CompletableUseCaseWithParameter</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Completable <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> Integer feedId)</span> &#123;</span><br><span class="line">    <span class="comment">//implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，幼稚的方法是编写像这样的测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeWhenDatabaseReturnsTrue</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeWithErrorInDatabase</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这被称为实现式命名。 它与类实现紧密结合。 当我们改变实施时，我们需要改变我们对类的期望。 这些通常是在代码之后编写的，关于它们唯一的好处是它们可以很快写入。</p>
<p>第二种方式是示例式命名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomethingWithIdsSmallerThanZero</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ignoreWhenNullIsPassed</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>示例式测试是系统使用的示例。 它们在测试边缘案例时很好，但不要将它们用于所有事情，它们应该与实现相关联。</p>
<p>现在，让我们尝试抽象我们对这个类的看法，并从实现中移开。 那这个呢：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldDeleteExistingFeed</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldIgnoreDeletingNonExistingFeed</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们确切地知道我们对这个类的期望。 这个测试类可以用作类的规范，因此可以使用名称规范式的命名。 名称没有说明实现的任何内容，并且从测试的名称 - 规范 - 我们可以编写实际的具体类。 规范样式的名称通常是最好的选择，但如果您认为您无法测试某些特定于实现的边缘案例，则可以随时抛出几个示例样式的测试。</p>
<p>理论到此为止，我们准备好让我们的手变dirty！</p>
<h3 id="3-测试Domain"><a href="#3-测试Domain" class="headerlink" title="3. 测试Domain"></a>3. 测试Domain</h3><p>让我们看看我们如何测试用例。 我们的Reedley应用程序中的用例结构如下所示：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-6.png" alt="Reedley App 3.1"></p>
<p>问题是EnableBackgroundFeedUpdatesUseCase是最终的，如果它是一些其他用例测试所需的模拟，则无法完成。 Mockito不允许嘲笑最终课程。</p>
<p>用例被其实现引用，所以让我们添加另一层接口：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-7.png" alt="Reedley App 3.2"></p>
<p>现在我们可以模拟EnableBackgroundFeedUpdatesUseCase接口。 但在我们的日常实践中，我们得出结论，这在开发时非常混乱，中间层接口是空的，用例实际上并不需要接口。 用例只做一项工作，它在名称中说得很对 - “启用后台供稿更新用例”，没有什么可以抽象的！</p>
<p>好的，让我们试试这个 - 我们不需要做最终用例。</p>
<p>我们尽可能做最后的决定，它使得更多结构化和更优化的代码。 我们可以忍受用例不是最终的，但必须有更好的方法。</p>
<p>我们找到了使用mockito-inline的解决方案。 它使得unmockable，mockable。 随着Mockito的新版本，可以启用最终classes的模拟。</p>
<p>以下是用例实现的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EnableBackgroundFeedUpdatesUseCase</span> <span class="keyword">implements</span> <span class="title class_">CompletableUseCase</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SetShouldUpdateFeedsInBackgroundUseCase setShouldUpdateFeedsInBackgroundUseCase;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FeedsUpdateScheduler feedsUpdateScheduler;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//constructor</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Completable <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> setShouldUpdateFeedsInBackgroundUseCase.execute(<span class="literal">true</span>)</span><br><span class="line">      .concatWith(Completable.fromAction(feedsUpdateScheduler::scheduleBackgroundFeedUpdates));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试用例时，我们应该测试该用例调用Repositories中的正确方法或执行其他用例。 我们还应该测试该用例返回适当的回调：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EnableBackgroundFeedUpdatesUseCase enableBackgroundFeedUpdatesUseCase;</span><br><span class="line"><span class="keyword">private</span> SetShouldUpdateFeedsInBackgroundUseCase setShouldUpdateFeedsInBackgroundUseCase;</span><br><span class="line"><span class="keyword">private</span> FeedsUpdateScheduler feedUpdateScheduler;</span><br><span class="line"><span class="keyword">private</span> TestSubscriber testSubscriber;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  setShouldUpdateFeedsInBackgroundUseCase = Mockito.mock(SetShouldUpdateFeedsInBackgroundUseCase.class);</span><br><span class="line">  feedUpdateScheduler = Mockito.mock(FeedsUpdateScheduler.class);</span><br><span class="line">  testSubscriber = <span class="keyword">new</span> <span class="title class_">TestSubscriber</span>();</span><br><span class="line">  enableBackgroundFeedUpdatesUseCase = <span class="keyword">new</span> <span class="title class_">EnableBackgroundFeedUpdatesUseCase</span>(</span><br><span class="line">    setShouldUpdateFeedsInBackgroundUseCase, </span><br><span class="line">    feedUpdateScheduler</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldEnableBackgroundFeedUpdates</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  Mockito.<span class="keyword">when</span>(setShouldUpdateFeedsInBackgroundUseCase.execute(<span class="literal">true</span>))</span><br><span class="line">    .thenReturn(Completable.complete());</span><br><span class="line">  </span><br><span class="line">  enableBackgroundFeedUpdatesUseCase.execute()</span><br><span class="line">    .subscribe(testSubscriber);</span><br><span class="line">  </span><br><span class="line">  Mockito.verify(setShouldUpdateFeedsInBackgroundUseCase, Mockito.times(<span class="number">1</span>))</span><br><span class="line">    .execute(<span class="literal">true</span>);</span><br><span class="line">  Mockito.verifyNoMoreInteractions(setShouldUpdateFeedsInBackgroundUseCase);</span><br><span class="line">  </span><br><span class="line">  Mockito.verify(feedUpdateScheduler, Mockito.times(<span class="number">1</span>))</span><br><span class="line">    .scheduleBackgroundFeedUpdates();</span><br><span class="line">  Mockito.verifyNoMoreInteractions(feedUpdateScheduler);</span><br><span class="line">  </span><br><span class="line">  testSubscriber.assertCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了来自Rx的 TestSubscriber ，因此可以测试适当的回调。 它可以断言完成，发射值，数值等。</p>
<h3 id="4-测试Data"><a href="#4-测试Data" class="headerlink" title="4. 测试Data"></a>4. 测试Data</h3><p>这里是非常简单的Repository方法，它只使用一个DAO方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FeedRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">FeedRepository</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FeedDao feedDao;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Scheduler backgroundScheduler;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//constructor</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Single <span class="title function_">feedExists</span><span class="params">(<span class="keyword">final</span> String feedUrl)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Single.defer(() -&gt; feedDao.doesFeedExist(feedUrl))</span><br><span class="line">      .subscribeOn(backgroundScheduler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//more methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试Repository时，我们应该测试它是否正确地使用了DAO方法，并且它是否在正确的线程上执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> FeedRepositoryImpl feedRepository;</span><br><span class="line"><span class="keyword">private</span> FeedDao feedDao;</span><br><span class="line"><span class="keyword">private</span> TestScheduler testScheduler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  feedDao = Mockito.mock(FeedDao.class);</span><br><span class="line">  testScheduler = <span class="keyword">new</span> <span class="title class_">TestScheduler</span>();</span><br><span class="line">  feedRepository = <span class="keyword">new</span> <span class="title class_">FeedRepositoryImpl</span>(feedDao, testScheduler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldCheckIfFeedExists</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">feedUrl</span> <span class="operator">=</span> <span class="string">&quot;http://example.com/feed&quot;</span>;</span><br><span class="line">  Mockito.<span class="keyword">when</span>(feedDao.doesFeedExist(feedUrl))</span><br><span class="line">    .thenReturn(Single.just(<span class="literal">true</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> TestSubscriber&lt;Boolean&gt; testSubscriber = <span class="keyword">new</span> <span class="title class_">TestSubscriber</span>&lt;&gt;();</span><br><span class="line">  feedRepository.feedExists(feedUrl)</span><br><span class="line">    .subscribe(testSubscriber);</span><br><span class="line">  </span><br><span class="line">  testSubscriber.assertNoValues();</span><br><span class="line">  testScheduler.triggerActions();</span><br><span class="line">  testSubscriber.assertValue(<span class="literal">true</span>);</span><br><span class="line">  testSubscriber.assertCompleted();</span><br><span class="line">  </span><br><span class="line">  Mockito.verify(feedDao, Mockito.times(<span class="number">1</span>))</span><br><span class="line">    .doesFeedExist(feedUrl);</span><br><span class="line">  Mockito.verifyNoMoreInteractions(feedDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-测试-App-module"><a href="#5-测试-App-module" class="headerlink" title="5. 测试 App module"></a>5. 测试 App module</h3><p>最后，让我们看看如何测试Presenter。 这是一个简单的Presenter，它从用例获取文章并将它们传递给视图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ArticlesPresenter</span> <span class="keyword">extends</span> <span class="title class_">BasePresenter</span> <span class="keyword">implements</span> <span class="title class_">ArticlesContract</span>.Presenter &#123;</span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  GetArticlesUseCase getArticlesUseCase;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  FeedViewModeMapper feedViewModeMapper;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// (...) more fields</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArticlesPresenter</span><span class="params">(<span class="keyword">final</span> ArticlesContract.View view)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(view);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fetchArticles</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> feedId)</span> &#123;</span><br><span class="line">    viewActionQueue.subscribeTo(</span><br><span class="line">      getArticlesUseCase.execute(feedId)</span><br><span class="line">        .map(feedViewModeMapper::mapArticlesToViewModels)</span><br><span class="line">        .map(<span class="built_in">this</span>::toViewAction),</span><br><span class="line">      Throwable::printStackTrace</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// (...) more methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Presenter通常有很多依赖关系。 我们通过@Inject注释将依赖关系注入Presenter，而不是通过构造函数。 所以在下面的测试中，我们需要使用@Mock和@Spy注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mock</span></span><br><span class="line">GetArticlesUseCase getArticlesUseCase;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mock</span></span><br><span class="line">FeedViewModeMapper feedViewModeMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mock</span></span><br><span class="line">ConnectivityReceiver connectivityReceiver;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mock</span></span><br><span class="line">ViewActionQueueProvider viewActionQueueProvider;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Spy</span></span><br><span class="line"><span class="type">Scheduler</span> <span class="variable">mainThreadScheduler</span> <span class="operator">=</span> Schedulers.immediate();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Spy</span></span><br><span class="line">MockViewActionQueue mockViewActionHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@InjectMocks</span></span><br><span class="line">ArticlesPresenter articlesPresenter;</span><br></pre></td></tr></table></figure>

<p>然后一些设置是必需的。 视图是手动模拟的，因为它是通过构造函数注入的，我们调用presenter.start()和presenter.activate()，因此演示程序已准备好并启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  view = Mockito.mock(ArticlesContract.View.class);</span><br><span class="line">  articlesPresenter = <span class="keyword">new</span> <span class="title class_">ArticlesPresenter</span>(view);</span><br><span class="line">  MockitoAnnotations.initMocks(<span class="built_in">this</span>);</span><br><span class="line">  </span><br><span class="line">  Mockito.<span class="keyword">when</span>(connectivityReceiver.getConnectivityStatus())</span><br><span class="line">    .thenReturn(Observable.just(<span class="literal">true</span>));</span><br><span class="line">  </span><br><span class="line">  Mockito.<span class="keyword">when</span>(viewActionQueueProvider.queueFor(Mockito.any()))</span><br><span class="line">    .thenReturn(<span class="keyword">new</span> <span class="title class_">MockViewActionQueue</span>());</span><br><span class="line">  </span><br><span class="line">  articlesPresenter.start();</span><br><span class="line">  articlesPresenter.activate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一切准备就绪后，我们可以开始编写测试。 准备好所有内容并确保Presenter在需要时调用视图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldFetchArticlesAndPassThemToView</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">feedId</span> <span class="operator">=</span> AppTestData.TEST_FEED_ID;</span><br><span class="line">  <span class="keyword">final</span> List&lt;Article&gt; articles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Article</span> <span class="variable">article</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Article</span>(</span><br><span class="line">    AppTestData.TEST_ARTICLE_ID,</span><br><span class="line">    feedId,</span><br><span class="line">    AppTestData.TEST_STRING,</span><br><span class="line">    AppTestData.TEST_LINK,</span><br><span class="line">    AppTestData.TEST_LONG_DATE,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line">  articles.add(article);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> List&lt;ArticleViewModel&gt; articleViewModels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ArticleViewModel</span> <span class="variable">articleViewModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArticleViewModel</span>(</span><br><span class="line">    AppTestData.TEST_ARTICLE_ID,</span><br><span class="line">    AppTestData.TEST_STRING,</span><br><span class="line">    AppTestData.TEST_LINK,</span><br><span class="line">    AppTestData.TEST_STRING,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line">  articleViewModels.add(articleViewModel);</span><br><span class="line">  </span><br><span class="line">  Mockito.<span class="keyword">when</span>(getArticlesUseCase.execute(feedId))</span><br><span class="line">    .thenReturn(Single.just(articles));</span><br><span class="line">  Mockito.<span class="keyword">when</span>(feedViewModeMapper.mapArticlesToViewModels(Mockito.anyList()))</span><br><span class="line">    .thenReturn(articleViewModels);</span><br><span class="line">  </span><br><span class="line">  articlesPresenter.fetchArticles(feedId);</span><br><span class="line">  </span><br><span class="line">  Mockito.verify(getArticlesUseCase, Mockito.times(<span class="number">1</span>))</span><br><span class="line">    .execute(feedId);</span><br><span class="line">  Mockito.verify(view, Mockito.times(<span class="number">1</span>))</span><br><span class="line">    .showArticles(articleViewModels);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在编码之前和期间考虑测试，这样你就可以编写可测试和解耦的代码。 使用你的测试作为类的规范，如果可能的话在代码之前写下它们。 不要让你的自我妨碍，我们都会犯错误。 因此，我们需要有一个流程来保护我们自己的应用程序！</p>
<p>这是Android Architecture系列的一部分。 想查看我们的其他部分可以：</p>
<p><a href="/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E5%9C%A8Android%E4%B8%8A%E5%BA%94%E7%94%A8Clean%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%AE%9E%E8%B7%B5%EF%BC%88%E5%8C%85%E5%90%AB%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%89-%E8%AF%91/">Part 4: Applying Clean Architecture on Android (Hands-on)</a></p>
<p><a href="/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%9C%A8Android%E4%B8%8A%E5%BA%94%E7%94%A8Clean%E6%9E%B6%E6%9E%84-%E8%AF%91/">Part 3: Applying Clean Architecture on Android</a></p>
<p><a href="/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-The-clean-architecture-%E8%AF%91/">Part 2: The Clean Architecture</a></p>
<p><a href="/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%AF%8F%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%E9%83%BD%E5%BE%88%E8%89%B0%E9%9A%BE-%E8%AF%91/">Part 1: every new beginning is hard</a> </p>
]]></content>
      <categories>
        <category>Android架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Clean架构</tag>
        <tag>译文</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM 架构，ViewModel 和LiveData 第一部分(译)</title>
    <url>/2018/05/13/MVVM%20%E6%9E%B6%E6%9E%84%EF%BC%8CViewModel%20%E5%92%8CLiveData%20%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>原文：MVVM architecture, ViewModel and LiveData (Part 1)</p>
<p>在Google I &#x2F; O期间，Google推出了包含LiveData 和ViewModel 的architecture components ，这有助于使用MVVM模式开发Android应用程序。 本文讨论这些组件如何为遵循MVVM的Android应用程序提供服务。</p>
<span id="more"></span>

<h3 id="快速定义MVVM"><a href="#快速定义MVVM" class="headerlink" title="快速定义MVVM"></a>快速定义MVVM</h3><p>如果您熟悉MVVM，则可以完全跳过本节。</p>
<p>MVVM是增强关注点分离的体系结构模式之一，它允许将用户界面逻辑从业务（或后端）逻辑中分离出来。 它的目标（与其他MVC模式目标一致）是为了实现以下原则：”使UI代码简单且不含应用程序逻辑，以便更易于管理”。</p>
<p>MVVM主要有以下几个层次：</p>
<ul>
<li><p>Model<br>Model表示应用程序的数据和业务逻辑。 这一层的推荐实施策略之一是通过观测数据并且公开其数据，从而完全从ViewModel或任何其他观察者&#x2F;消费者（这将在我们的MVVM示例应用程序中进行说明）进行解耦。</p>
</li>
<li><p>ViewModel<br>ViewModel与Model交互，并且还准备可以被View观察的observable（s）。 ViewModel可以选择性地为View提供钩子（hooks）以将事件传递给Model。<br>该层的一个重要实现策略是将其与View分离，即ViewModel不应该意识到与之交互的View。</p>
</li>
<li><p>View<br>最后，此模式中的View是观察（或订阅）ViewModel，可观察数据以获取数据并且相应地更新UI元素。</p>
</li>
</ul>
<p>下图显示了MVVM组件和基本交互。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*BpxMFh7DdX0_hqX6ABkDgw.png" alt="MVVM组件和基本交互"></p>
<h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p>如上所述，LiveData是新引入的体系结构组件之一。 LiveData是一个可观察的数据持有者。 这允许应用程序中的组件能够观察LiveData对象的更改，而无需在它们之间创建明确的和严格的依赖关系路径。 这将完全分离LiveData对象使用者的LiveData对象生产者。</p>
<p>除此之外，LiveData也有很大的好处，LiveData尊重应用程序组件（活动，片段，服务）的生命周期状态，并处理对象生命周期管理，确保LiveData对象不泄漏。</p>
<blockquote>
<p>根据Google文档，如果您已经在使用Rx或Agera等Library，则可以继续使用它们而不是LiveData。 但在这种情况下，您有责任处理每个Android组件生命周期的对象分配和解除分配。</p>
</blockquote>
<p>由于LiveData尊重Android生命周期，这意味着除非LiveData主机（activity或fragment）处于活动状态（接收onStart()但未收到onStop()），否则它将不会调用其观察者回调。 除此之外，当主机收到onDestroy()时，LiveData也会自动删除观察者。</p>
<p>LiveData将在下面的MVVM示例应用程序中进行说明。</p>
<h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>ViewModel也是新引入的体系结构组件之一。 architecture components 提供了一个名为<strong>ViewModel</strong>的新类，它负责为UI &#x2F; View准备数据。</p>
<p><strong>ViewModel</strong>为您的MVVM ViewModel层提供了一个很好的基类，因为<strong>ViewModel</strong>（及其子类<strong>AndroidViewModel</strong>）的扩展类在配置更改期间自动保留其保留数据。 这意味着，在配置更改后，此<strong>ViewModel</strong>所有数据立即可用于下一个Activity或Fragment实例。</p>
<p>下图显示了ViewModel组件的生命周期。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*uWXunt0A6fKUFU8PsTLkfA.png" alt="ViewModel组件的生命周期"></p>
<p><strong>ViewModel</strong>也将在我们的MVVM示例应用程序中进行说明。</p>
<h3 id="示例应用程序"><a href="#示例应用程序" class="headerlink" title="示例应用程序"></a>示例应用程序</h3><p>现在，让我们来看看最有趣的部分，让我们把所有这些东西放在一个示例应用程序中。 此MVVM示例应用程序主要包含两个屏幕。 下面显示的第一个屏幕显示了Google GitHub项目列表，其中包含一些简要信息，例如标题，编程语言和最终观察者数量。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*vt5V03Pe1Va7B0vGfceRpQ.png" alt="Project List"></p>
<p>一旦应用程序的最终用户触摸任何列表项、GitHub项目的详细信息，屏幕将显示项目描述、编程语言、观察者数量、公开问题、创建和上次更新日期，最后显示克隆URL。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*7dR3uzZsANvvjJp3twYINg.png" alt="Project Details"></p>
<h3 id="示例应用程序交互图"><a href="#示例应用程序交互图" class="headerlink" title="示例应用程序交互图"></a>示例应用程序交互图</h3><p>下图显示了示例应用程序的包结构</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*2AIrQEjTkInY_BjUW9slSw.png" alt="示例应用程序的包结构"></p>
<p>以下交互图显示了检索Google GitHub项目的应用场景之一的示例交互图。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*uCmP51XYJCuffo4fXe2KFg.png" alt="Google GitHub项目的应用场景"></p>
<p>如图所示，每个图层都从其后续图层（Fragment（View） - &gt; ViewModel - &gt; Repository）观察LiveData，最后一旦检索到项目列表，就会使用RecyclerView适配器绑定显示项目列表。</p>
<blockquote>
<p>Repository模块负责处理数据操作。 通过确保这一点，Repository模块可以为应用程序的其余部分提供干净的API，并简化使用者ViewModel的工作。 如果需要更新数据，系统信息库模块应该知道从哪里获取数据以及进行哪些API调用。 它们可以被视为不同数据源（REST服务，数据库，XML文件等）之间的中介。</p>
</blockquote>
<p>现在，让我们从下往上解释这些图层，从Model，ViewModel开始，最后用View来检索GitHub项目场景。</p>
<h3 id="示例应用程序模型层"><a href="#示例应用程序模型层" class="headerlink" title="示例应用程序模型层"></a>示例应用程序模型层</h3><p>让我们从业务逻辑层开始，我们有两个模型对象</p>
<ul>
<li><strong>Project</strong>，包含GitHub项目的信息，如id，名称，描述，创建日期等等。</li>
<li><strong>用户</strong>，包含GitHub项目所有者的用户信息。</li>
</ul>
<p>为了与GitHub RESTful API进行交互，我使用了我喜欢的Retrofit 2来定义存储库包中的以下简单接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GithubService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(&quot;users/&#123;user&#125;/repos&quot;)</span></span><br><span class="line">    Single&lt;List&lt;Project&gt;&gt; <span class="title function_">getProjectList</span><span class="params">(<span class="meta">@Path(&quot;user&quot;)</span> String userId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(&quot;repos/&#123;user&#125;/&#123;repoName&#125;&quot;)</span></span><br><span class="line">    Single&lt;Project&gt; <span class="title function_">getProjectDetails</span><span class="params">(<span class="meta">@Path(&quot;user&quot;)</span> String userId, <span class="meta">@Path(&quot;repoName&quot;)</span> String projectName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了便于ViewModel的Job，创建一个<strong>ProjectRepository</strong>类来与GitHub服务交互，并最终为ViewModel提供一个<strong>LiveData</strong>对象。 它也将在以后用于编排服务呼叫。 以下代码片段显示了**getProjectList()**API实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectRepository</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> GithubService githubService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor and helper methods</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;Project&gt;&gt; <span class="title function_">getProjectList</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> MutableLiveData&lt;List&lt;Project&gt;&gt; data = <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        githubService.getProjectList(userId)</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(<span class="keyword">new</span> <span class="title class_">SingleObserver</span>&lt;List&lt;Project&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(List&lt;Project&gt; projects)</span> &#123;</span><br><span class="line">                        data.setValue(projects);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                        <span class="comment">// handle the error case</span></span><br><span class="line">                        <span class="comment">//Yet, do not do nothing in this app. In a real world, this should be handled</span></span><br><span class="line">                        System.out.println(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ProjectRepository</strong>是ViewModel的数据提供者，它具有<strong>getProjectList()</strong>，它将响应简单地包装到LiveData Object中。</p>
<p>为了简化本文的目的，错误处理被省略，并且将在下一篇文章中进行说明。</p>
<h3 id="示例应用程序ViewModel图层"><a href="#示例应用程序ViewModel图层" class="headerlink" title="示例应用程序ViewModel图层"></a>示例应用程序ViewModel图层</h3><p>为了消费<strong>getProjectList（）<strong>API，创建了ViewModel类（调用Repository API并可以为LiveData执行任何所需的转换）。 以下代码片段显示了</strong>ProjectListViewModel</strong>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectListViewModel</span> <span class="keyword">extends</span> <span class="title class_">AndroidViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LiveData&lt;List&lt;Project&gt;&gt; projectListObservable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProjectRepository projectRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProjectListViewModel</span><span class="params">(<span class="meta">@NonNull</span> Application application)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(application);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If any transformation is needed, this can be simply done by Transformations class ...</span></span><br><span class="line">        projectRepository = <span class="keyword">new</span> <span class="title class_">ProjectRepository</span>();</span><br><span class="line">        projectListObservable = projectRepository.getProjectList(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Expose the LiveData Projects query so the UI can observe it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;Project&gt;&gt; <span class="title function_">getProjectListObservable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> projectListObservable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，我们的<strong>ProjectListViewModel</strong>类扩展了<strong>AndroidViewModel</strong>，并在构造函数中调用**getProjectList（”Google”）**来检索Google GitHub项目。</p>
<p>在现实世界的情况下，在将结果数据传递给观察视图之前可能需要进行转换，为了进行转换，可以使用Transformation类，如下面的文档所示：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9saXZlZGF0YS5odG1sI3RyYW5zZm9ybWF0aW9uc19vZl9saXZlZGF0YQ==">https://developer.android.com/topic/libraries/architecture/livedata.html#transformations_of_livedata<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="示例应用视图图层"><a href="#示例应用视图图层" class="headerlink" title="示例应用视图图层"></a>示例应用视图图层</h3><p>最后，让我们快速浏览一下这个应用程序的视图层，我们主要有一个名为<strong>MainActivity</strong>的Activity，它负责处理代表应用程序视图的两个片段的导航：</p>
<ul>
<li><strong>ProjectListFragment</strong>，它显示Google GitHub项目的列表。</li>
<li><strong>ProjectFragment</strong>，它显示所选的GitHub项目细节。</li>
</ul>
<blockquote>
<p>由于Activities和Fragments被视为生命周期所有者，活动需要扩展LifecycleActivity，片段需要扩展LifecycleFragment。 但是，请务必记住LifecycleActivity和LifecycleFragment类都是临时实现，直到Lifecycle与支持库集成为止：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvYXJjaC9saWZlY3ljbGUvTGlmZWN5Y2xlQWN0aXZpdHkuaHRtbA==">https://developer.android.com/reference/android/arch/lifecycle/LifecycleActivity.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>现在，让我们继续我们的项目检索方案，查看<strong>ProjectListFragment</strong>，下面的代码片段显示了最重要的集成部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectListFragment</span> <span class="keyword">extends</span> <span class="title class_">LifecycleFragment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ProjectAdapter projectAdapter;</span><br><span class="line">    <span class="keyword">private</span> FragmentProjectListBinding binding;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container,</span></span><br><span class="line"><span class="params">                           <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        binding = DataBindingUtil.inflate(inflater, R.layout.fragment_project_list, container, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        projectAdapter = <span class="keyword">new</span> <span class="title class_">ProjectAdapter</span>(projectClickCallback);</span><br><span class="line">        binding.projectList.setAdapter(projectAdapter);</span><br><span class="line">        binding.setIsLoading(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> binding.getRoot();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProjectListViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> ViewModelProviders.of(<span class="built_in">this</span>).get(ProjectListViewModel.class);</span><br><span class="line"></span><br><span class="line">        observeViewModel(viewModel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">observeViewModel</span><span class="params">(ProjectListViewModel viewModel)</span> &#123;</span><br><span class="line">        <span class="comment">// Update the list when the data changes</span></span><br><span class="line">        viewModel.getProjectListObservable().observe(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;List&lt;Project&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(<span class="meta">@Nullable</span> List&lt;Project&gt; projects)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (projects != <span class="literal">null</span>) &#123;</span><br><span class="line">                    binding.setIsLoading(<span class="literal">false</span>);</span><br><span class="line">                    projectAdapter.setProjectList(projects);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ProjectClickCallback</span> <span class="variable">projectClickCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProjectClickCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(Project project)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.STARTED)) &#123;</span><br><span class="line">                ((MainActivity) getActivity()).show(project);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，<strong>ProjectListFragment</strong>获取<strong>ProjectListViewModel</strong>，然后监听其<strong>getProjectListObservable（）<strong>方法，以便在准备好时获取Github项目列表。 最后，一旦检索到项目列表，它将被传递给</strong>projectAdapter</strong>（RecyclerView适配器），以显示RecyclerView组件中的项目列表。</p>
<p>这是对项目的一个端到端场景的解释，您可以在这里找到GitHub中提供的完整项目：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhemVtcy9tdnZtLXNhbXBsZS1hcHAvdHJlZS9wYXJ0MQ==">https://github.com/hazems/mvvm-sample-app/tree/part1<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="MVVM实施的重要指导原则"><a href="#MVVM实施的重要指导原则" class="headerlink" title="MVVM实施的重要指导原则"></a>MVVM实施的重要指导原则</h3><p>现在，重点介绍MVVM实现的一些重要指导原则：</p>
<ul>
<li>如示例中所示，ViewModels不会直接引用Views，因为如果这样做，ViewModels可能会超出View的生命周期，并且可能会发生内存泄漏。</li>
<li>建议使用Model和ViewModel使用LiveData公开其数据，因为LiveData尊重应用程序组件（活动，片段，服务）的生命周期状态，并处理确保LiveData对象不泄漏的对象生命周期管理。</li>
</ul>
<h3 id="下一篇文章"><a href="#下一篇文章" class="headerlink" title="下一篇文章"></a>下一篇文章</h3><p>故事尚未完成，因为有些事情需要处理，比如：</p>
<ul>
<li>依赖注入</li>
<li>错误处理</li>
<li>缓存</li>
<li>在此演示中添加更多功能以查看Room如何促进SQLite数据操作</li>
<li>单元测试</li>
<li>其他…</li>
</ul>
<p>这将在MVVM的下一系列文章中进行说明，敬请关注。 </p>
]]></content>
      <categories>
        <category>Android架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>译文</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM 架构，ViewModel 和LiveData 第二部分(译)</title>
    <url>/2018/05/20/MVVM%20%E6%9E%B6%E6%9E%84%EF%BC%8CViewModel%20%E5%92%8CLiveData%20%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>原文：MVVM architecture, ViewModel and LiveData (Part ２)</p>
<p>在Google I &#x2F; O期间，Google推出了包含LiveData 和ViewModel 的architecture components ，这有助于使用MVVM模式开发Android应用程序。 本文讨论这些组件如何为遵循MVVM的Android应用程序提供服务。</p>
<p>在本系列的第一篇文章中，我们讨论了这些组件如何为遵循MVVM的Android应用程序提供服务。 在第二篇文章中，我们将回答在依赖注入的第一篇文章结尾处提出的其中一个问题。</p>
<p>本文假定您具有Dagger的基本知识，因为我们将专注于在MVVM示例中设置最新的Dagger版本（版本2.11）以实现依赖注入。</p>
<blockquote>
<p>如果您需要关于Dagger 2.11的基本信息，请查看Dagger用户指南。</p>
</blockquote>
<span id="more"></span>

<h3 id="配置Dagger-2-11"><a href="#配置Dagger-2-11" class="headerlink" title="配置Dagger 2.11"></a>配置Dagger 2.11</h3><p>首先，让我们将Dagger 2.11依赖添加到我们的MVVM Sample。</p>
<h4 id="指定Dagger版本2-11"><a href="#指定Dagger版本2-11" class="headerlink" title="指定Dagger版本2.11"></a>指定Dagger版本2.11</h4><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>.ext &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    dagger_version = <span class="string">&quot;2.11&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">annotationProcessor <span class="string">&quot;com.google.dagger:dagger-compiler:$dagger_version&quot;</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">&quot;com.google.dagger:dagger:$project.dagger_version&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">&quot;com.google.dagger:dagger-android:$project.dagger_version&quot;</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">&quot;com.google.dagger:dagger-android-support:$project.dagger_version&quot;</span></span><br><span class="line">annotationProcessor <span class="string">&quot;com.google.dagger:dagger-android-processor:$dagger_version&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Dagger-2-11项目设置"><a href="#Dagger-2-11项目设置" class="headerlink" title="Dagger 2.11项目设置"></a>Dagger 2.11项目设置</h3><p>下图显示了本示例中的主Dagger 2.11设置。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*ued7xwa6lGHiGrvGO-8PvA.png" alt="Dagger 2.11 setup in MVVM Sample"></p>
<p>我们主要有以下Dagger App类&#x2F;接口：</p>
<ol>
<li><strong>AppModule</strong>是一个Dagger模块，负责在应用程序级别提供单例服务，例如<strong>GitHubService</strong>和<strong>ProjectViewModelFactory</strong>。</li>
<li><strong>AppComponent</strong>负责注入<strong>AppModule</strong>。</li>
<li><strong>ViewModelSubComponent</strong>是创建View Model实例的子组件。</li>
<li><strong>MainActivityModule</strong>和<strong>FragmentBuildersModule</strong>是Activity和Fragment实例提供程序。</li>
<li><strong>Injectable</strong>只是可注射Fragment的标记接口。</li>
<li><strong>AppInjector</strong>是一个辅助类，用于在实现<strong>Injectable</strong>接口时自动注入Fragments。</li>
</ol>
<p>现在，让我们进入这个设置中每个Dagger项目的细节。</p>
<h3 id="创建-View-Model-SubComponent"><a href="#创建-View-Model-SubComponent" class="headerlink" title="创建 View Model SubComponent"></a>创建 View Model SubComponent</h3><p>以下代码片断显示了<strong>ViewModelSubComponent</strong>接口，该接口负责创建ViewModel实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Subcomponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewModelSubComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        ViewModelSubComponent <span class="title function_">build</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProjectListViewModel <span class="title function_">projectListViewModel</span><span class="params">()</span>;</span><br><span class="line">    ProjectViewModel <span class="title function_">projectViewModel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，<strong>ViewModelSubComponent</strong>将被<strong>ProjectViewModelFactory</strong>调用以获取ViewModel实例。</p>
<blockquote>
<p>但什么是_ProjectViewModelFactory_？</p>
</blockquote>
<p>下一节回答这个问题。</p>
<h3 id="创建自定义View-Model-Factory"><a href="#创建自定义View-Model-Factory" class="headerlink" title="创建自定义View Model Factory"></a>创建自定义View Model Factory</h3><p><strong>ProjectViewModelFactory</strong>是一个扩展<strong>ViewModelProvider.Factory</strong>以便将ViewModel实例提供给使用者Fragment类的工厂。</p>
<p>以下代码片段显示了<strong>ProjectViewModelFactory</strong>，它是一个扩展<strong>ViewModelProvider.Factory</strong>的自解释Factory实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectViewModelFactory</span> <span class="keyword">implements</span> <span class="title class_">ViewModelProvider</span>.Factory &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;Class, Callable&lt;? <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt;&gt; creators;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProjectViewModelFactory</span><span class="params">(ViewModelSubComponent viewModelSubComponent)</span> &#123;</span><br><span class="line">        creators = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// View models cannot be injected directly because they won&#x27;t be bound to the owner&#x27;s</span></span><br><span class="line">        <span class="comment">// view model scope.</span></span><br><span class="line">        creators.put(ProjectViewModel.class, () -&gt; viewModelSubComponent.projectViewModel());</span><br><span class="line">        creators.put(ProjectListViewModel.class, () -&gt; viewModelSubComponent.projectListViewModel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">create</span><span class="params">(Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">        Callable&lt;? <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; creator = creators.get(modelClass);</span><br><span class="line">        <span class="keyword">if</span> (creator == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class, Callable&lt;? <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt;&gt; entry : creators.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (modelClass.isAssignableFrom(entry.getKey())) &#123;</span><br><span class="line">                    creator = entry.getValue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (creator == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown model class &quot;</span> + modelClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) creator.call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们看下一节中的主要应用程序模块。</p>
<h3 id="创建App模块"><a href="#创建App模块" class="headerlink" title="创建App模块"></a>创建App模块</h3><p><strong>AppModule</strong>是一个Dagger模块，负责在应用程序级别为消费者提供单例服务，例如<strong>GitHubService</strong>和<strong>ProjectViewModelFactory</strong>。 以下代码片段显示了<strong>AppModule</strong>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module(subcomponents = ViewModelSubComponent.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppModule</span> &#123;</span><br><span class="line">    <span class="meta">@Singleton</span> <span class="meta">@Provides</span></span><br><span class="line">    GitHubService <span class="title function_">provideGithubService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">                .baseUrl(GitHubService.HTTPS_API_GITHUB_URL)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .build()</span><br><span class="line">                .create(GitHubService.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    ViewModelProvider.Factory <span class="title function_">provideViewModelFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            ViewModelSubComponent.Builder viewModelSubComponent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProjectViewModelFactory</span>(viewModelSubComponent.build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的一点是，不要忘记通过在**@Module<strong>注解的</strong>subcomponents<strong>参数中指定</strong>ViewModelSubComponent<strong>到</strong>AppModule**。</p>
<h3 id="创建-Injectable和-AppInjector"><a href="#创建-Injectable和-AppInjector" class="headerlink" title="创建 Injectable和 AppInjector"></a>创建 Injectable和 AppInjector</h3><p>可注入接口只是一个普通的空白标记接口，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Injectable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Injectable</strong>将由可注射的Fragment实施。</p>
<p>为了在实现<strong>Injectable</strong>接口时自动注入片段，将创建以下<strong>AppInjector</strong>助手类，以在**onFragmentCreated（）**上注入片段实例，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppInjector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">AppInjector</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(MVVMApplication mvvmApplication)</span> &#123;</span><br><span class="line">        DaggerAppComponent.builder().application(mvvmApplication)</span><br><span class="line">                .build().inject(mvvmApplication);</span><br><span class="line"></span><br><span class="line">        mvvmApplication</span><br><span class="line">                .registerActivityLifecycleCallbacks(<span class="keyword">new</span> <span class="title class_">Application</span>.ActivityLifecycleCallbacks() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">                        handleActivity(activity);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Other methods are omitted for simplification ...</span></span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleActivity</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> HasSupportFragmentInjector) &#123;</span><br><span class="line">            AndroidInjection.inject(activity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">            ((FragmentActivity) activity).getSupportFragmentManager()</span><br><span class="line">                    .registerFragmentLifecycleCallbacks(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">FragmentManager</span>.FragmentLifecycleCallbacks() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFragmentCreated</span><span class="params">(FragmentManager fm, Fragment fragment,</span></span><br><span class="line"><span class="params">                                                              Bundle savedInstanceState)</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (fragment <span class="keyword">instanceof</span> Injectable) &#123;</span><br><span class="line">                                        AndroidSupportInjection.inject(fragment);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点需要注意，**AppInjector.init（）**将在应用程序启动时调用（正如我们将在自定义应用程序类部分中展示的那样）。</p>
<h3 id="创建-Activity-和-Fragment-Modules"><a href="#创建-Activity-和-Fragment-Modules" class="headerlink" title="创建 Activity 和 Fragment Modules"></a>创建 Activity 和 Fragment Modules</h3><p>以下代码片段显示了Fragments Dagger模块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FragmentBuildersModule</span> &#123;</span><br><span class="line">    <span class="meta">@ContributesAndroidInjector</span></span><br><span class="line">    <span class="keyword">abstract</span> ProjectFragment <span class="title function_">contributeProjectFragment</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ContributesAndroidInjector</span></span><br><span class="line">    <span class="keyword">abstract</span> ProjectListFragment <span class="title function_">contributeProjectListFragment</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Dagger 2.10开始，<strong>@ContributesAndroidInjector</strong>轻松将活动和片段附加到匕首图上。 以下代码片断显示了<strong>MainActivityModule</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MainActivityModule</span> &#123;</span><br><span class="line">    <span class="meta">@ContributesAndroidInjector(modules = FragmentBuildersModule.class)</span></span><br><span class="line">    <span class="keyword">abstract</span> MainActivity <span class="title function_">contributeMainActivity</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们来看看Dagger 2.11设置中的最后一项，即<strong>AppComponent</strong>。</p>
<h3 id="创建AppComponent"><a href="#创建AppComponent" class="headerlink" title="创建AppComponent"></a>创建AppComponent</h3><p>下一个代码片段显示了<strong>AppComponent</strong>接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component(modules = &#123;</span></span><br><span class="line"><span class="meta">        AndroidInjectionModule.class,</span></span><br><span class="line"><span class="meta">        AppModule.class,</span></span><br><span class="line"><span class="meta">        MainActivityModule.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Component</span>.Builder</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="meta">@BindsInstance</span> Builder <span class="title function_">application</span><span class="params">(Application application)</span>;</span><br><span class="line">        AppComponent <span class="title function_">build</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(MVVMApplication mvvmApplication)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一件重要的事情要注意，除了包括<strong>AppModule</strong>和<strong>MainActivityModule</strong>之外，我们还根据官方文档向<strong>AppComponent</strong>添加了<strong>AndroidSupportInjectionModule</strong>，该文档声明有必要确保所有必要的绑定都可用。 <strong>AndroidSupportInjectionModule</strong>是dagger-android中的一个内置模块：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9kYWdnZXIvYmxvYi9tYXN0ZXIvamF2YS9kYWdnZXIvYW5kcm9pZC9zdXBwb3J0L0FuZHJvaWRTdXBwb3J0SW5qZWN0aW9uTW9kdWxlLmphdmE=">https://github.com/google/dagger/blob/master/java/dagger/android/support/AndroidSupportInjectionModule.java<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="更新存储库层实现"><a href="#更新存储库层实现" class="headerlink" title="更新存储库层实现"></a>更新存储库层实现</h3><p>现在，我们完成了设置Dagger 2.11，让我们更新我们现有的应用程序代码，以便利用Dagger依赖注入。</p>
<p><strong>ProjectRepository</strong>不再需要手动创建<strong>GitHubService</strong>服务实例，它所需要做的就是在它的<strong>GitHubService</strong>实例的构造函数中使用**@Inject**，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectRepository</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> GitHubService gitHubService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProjectRepository</span><span class="params">(GitHubService gitHubService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gitHubService = gitHubService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other methods here are omitted for simplicity ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新ViewModel层实现"><a href="#更新ViewModel层实现" class="headerlink" title="更新ViewModel层实现"></a>更新ViewModel层实现</h3><p>更新ViewModel图层也是必要的，以避免在此图层内手动从<strong>ProjectRepository</strong>创建实例。</p>
<p>以下代码片段显示了<strong>ProjectViewModel</strong>的一个示例，该示例使用@inject注释来注入<strong>Application</strong>和<strong>ProjectRepository</strong>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectViewModel</span> <span class="keyword">extends</span> <span class="title class_">AndroidViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> ProjectViewModel.class.getName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MutableLiveData</span> <span class="variable">ABSENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        ABSENT.setValue(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LiveData&lt;Project&gt; projectObservable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;String&gt; projectID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ObservableField&lt;Project&gt; project = <span class="keyword">new</span> <span class="title class_">ObservableField</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProjectViewModel</span><span class="params">(<span class="meta">@NonNull</span> ProjectRepository projectRepository, <span class="meta">@NonNull</span> Application application)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(application);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.projectID = <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        projectObservable = Transformations.switchMap(projectID, input -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (input.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> ABSENT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> projectRepository.getProjectDetails(<span class="string">&quot;Google&quot;</span>, projectID.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Code is omitted for simplicity ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新视图实现（Fragments和主要的Activity）"><a href="#更新视图实现（Fragments和主要的Activity）" class="headerlink" title="更新视图实现（Fragments和主要的Activity）"></a>更新视图实现（Fragments和主要的Activity）</h3><p>更新视图层也是必要的，以避免在该图层内手动创建ViewModel类的实例。</p>
<p>以下代码片段显示了<strong>ProjectFragment</strong>的一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectFragment</span> <span class="keyword">extends</span> <span class="title class_">LifecycleFragment</span> <span class="keyword">implements</span> <span class="title class_">Injectable</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    ViewModelProvider.Factory viewModelFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProjectViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> ViewModelProviders.of(<span class="built_in">this</span>, viewModelFactory)</span><br><span class="line">                .get(ProjectViewModel.class);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的一些重点：</p>
<ol>
<li>现在每个Fragment都必须实现可注入接口。</li>
<li>Fragment应该引用<strong>ViewModelProvider.Factory</strong>以获取ViewModel实例。</li>
</ol>
<h3 id="创建定制-Application类"><a href="#创建定制-Application类" class="headerlink" title="创建定制 Application类"></a>创建定制 Application类</h3><p>最后，我们的自定义application类代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MVVMApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> <span class="keyword">implements</span> <span class="title class_">HasActivityInjector</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    DispatchingAndroidInjector&lt;Activity&gt; dispatchingAndroidInjector;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        AppInjector.init(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DispatchingAndroidInjector&lt;Activity&gt; <span class="title function_">activityInjector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatchingAndroidInjector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意两点：</p>
<ol>
<li>Application必须实现<strong>HasActivityInjector</strong>，并**@Inject DispatchingAndroidInjector** 才能从**activityInjector（）**方法返回。</li>
<li>在Application类的<strong>onCreate（）<strong>中，我们初始化</strong>AppInjector</strong>以便在实现<strong>Injectable</strong>接口时自动注入Fragments。</li>
</ol>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>在GitHub中检查更新的应用程序的源代码，随意随意分叉和更新，如你所愿：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhemVtcy9tdnZtLXNhbXBsZS1hcHAvdHJlZS9wYXJ0Mg==">https://github.com/hazems/mvvm-sample-app/tree/part2<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="下一步是什么"><a href="#下一步是什么" class="headerlink" title="下一步是什么"></a>下一步是什么</h3><p>在本文后，您现在有足够的信息来使用Google Architectural components创建自己的MVVM应用程序。 希望我能为本系列的下一篇文章留有余地，内容包括以下主题：</p>
<ol>
<li>错误处理。</li>
<li>在此演示中添加更多功能，以了解Room如何促进SQLite数据操作，以及如何实现有效的缓存。</li>
<li>单元测试。</li>
<li>我们在哪里可以将Rx用于此架构？</li>
<li>我们如何使用Kotlin简化这个实现？ （旅程真的有很多有趣的东西 : )）。</li>
</ol>
<p>如果你喜欢这篇文章，我感谢你的支持与他人分享这篇文章，让伟大的Android社区知道。 </p>
]]></content>
      <categories>
        <category>Android架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>译文</tag>
        <tag>MVVM</tag>
        <tag>Dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title>Android架构：第四部分-在Android上应用Clean架构，实践（包含源代码）(译)</title>
    <url>/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E5%9C%A8Android%E4%B8%8A%E5%BA%94%E7%94%A8Clean%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%AE%9E%E8%B7%B5%EF%BC%88%E5%8C%85%E5%90%AB%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%89/</url>
    <content><![CDATA[<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-1.png" alt="clean architecture"></p>
<p>在Android Architecture系列的最后一部分，我们将Clean Architecture稍微调整到了Android平台。 我们将Android和现实世界从业务逻辑中分离出来，让满意的利益相关者满意，并让所有事情都可以轻松测试。</p>
<p>这个理论很好，但是当我们创建一个新的Android项目时，我们从哪里开始？ 让我们用干净的代码弄脏我们的手，并将空白的画布变成一个架构。</p>
<span id="more"></span>

<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>我们将首先奠定基础 - 创建模块并建立它们之间的依赖关系，以便与依赖规则保持一致。</p>
<p>这些将是我们的模块，从最抽象的一个到具体的实现：</p>
<h3 id="1-domain"><a href="#1-domain" class="headerlink" title="1. domain"></a>1. domain</h3><p>Entities, use cases, repositories interfaces, 和 device interfaces 进入 domain module。</p>
<p>理想情况下，实体和业务逻辑应该是平台不可知的。 为了安全起见，为了防止我们在这里放置一些Android的东西，我们将使它成为一个纯粹的Java模块。</p>
<h3 id="2-data"><a href="#2-data" class="headerlink" title="2. data"></a>2. data</h3><p>数据模块应包含与数据持久性和操作相关的所有内容。 在这里，我们将找到DAO，ORM，SharedPreferences，网络相关的东西，例如Retrofit服务和类似的东西。</p>
<h3 id="3-device"><a href="#3-device" class="headerlink" title="3. device"></a>3. device</h3><p>设备模块应该包含与Android相关的所有内容，而不是数据持久性和UI。 例如，ConnectivityManager，NotificationManager和misc传感器的包装类。</p>
<p>我们将使数据和设备模块都是Android模块，因为他们必须了解Android并且不能是纯Java。</p>
<h3 id="4-The-easiest-part-app-module-UI-module"><a href="#4-The-easiest-part-app-module-UI-module" class="headerlink" title="4. The easiest part, app module (UI module)"></a>4. The easiest part, app module (UI module)</h3><p>创建项目时，Android模块已经为您创建了该模块。</p>
<p>在这里，您可以放置与Android UI相关的所有类，例如presenters，controllers，view models，adapters和views。</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>依赖规则定义具体模块依赖于更抽象的模块。</p>
<p>您可能还记得，从本系列的第三部分可以看出，UI（应用程序），DB-API（数据）和Device（设备）等东西都在外环中。 这意味着它们处于相同的抽象层次。 我们如何将它们连接在一起呢？</p>
<p>理想情况下，这些模块仅取决于域模块。 在这种情况下，依赖关系看起来有点像明星：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-2.png" alt="clean architecture"></p>
<p>但是，我们在这里与Android打交道，事情并不完美。 因为我们需要创建对象图并初始化事物，所以模块有时依赖于domain以外的其他模块。</p>
<p>例如，我们正在app模块中创建用于依赖注入的对象图。 这迫使APP模块了解所有其他模块。</p>
<p>我们调整后的依赖关系图：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-3.png" alt="clean architecture"></p>
<p>最后，是时候编写一些代码。 为了更容易，我们将以RSS Reader APP为例。 我们的用户应该能够管理他们的RSS提要订阅，从提要中获取文章并阅读它们。</p>
<h2 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h2><p>让我们从domain层开始，创建我们的核心业务模型和逻辑。</p>
<p>我们的商业模式非常简单：</p>
<ul>
<li><em>Feed</em> - 持有RSS提要相关数据，如网址，缩略图网址，标题和说明</li>
<li><em>Article</em> - 保存文章相关数据，如文章标题，网址和发布日期</li>
</ul>
<p>而对于我们的逻辑，我们将使用UseCases。 他们在简洁的类中封装了小部分业务逻辑。 他们都将实施通用的UseCase 契约类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UseCase</span>&lt;P&gt; &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(P parameter, Callback callback)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的用户在打开我们的应用时首先要做的就是添加一个新的RSS订阅。 因此，要开始使用我们的Use Case，我们将创建_AddNewFeedUseCase_及其助手来处理Feed的添加和验证逻辑。</p>
<p>_AddNewFeedUseCase_将使用_FeedValidator_来检查Feed URL的有效性，并且我们还将创建FeedRepository 契约类，这将为我们的业务逻辑提供一些基本的CRUD功能来管理供稿数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FeedRepository</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">createNewFeed</span><span class="params">(String feedUrl)</span>;</span><br><span class="line">  List&lt;Feed&gt; <span class="title function_">getUserFeeds</span><span class="params">()</span>;</span><br><span class="line">  List&lt;Article&gt; <span class="title function_">getFeedArticles</span><span class="params">(<span class="type">int</span> feedId)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">deleteFeed</span><span class="params">(<span class="type">int</span> feedId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意我们在Domain层的命名是如何清楚地传递我们的APP正在做什么的想法。</p>
<p>把所有东西放在一起，我们的_AddNewFeedUseCase_看起来像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AddNewFeedUseCase</span> <span class="keyword">implements</span> <span class="title class_">UseCase</span>&lt;String&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FeedValidator feedValidator;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FeedRepository feedRepository;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> String feedUrl, <span class="keyword">final</span> Callback callback)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (feedValidator.isValid(feedUrl)) &#123;</span><br><span class="line">      onValidFeedUrl(feedUrl, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callback.onError(<span class="keyword">new</span> <span class="title class_">InvalidFeedUrlException</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onValidFeedUrl</span><span class="params">(<span class="keyword">final</span> String feedUrl, <span class="keyword">final</span> Callback callback)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      feedRepository.createNewFeed(feedUrl);</span><br><span class="line">      callback.onSuccess();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable throwable) &#123;</span><br><span class="line">      callback.onError(throwable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:为简洁起见，省略构造函数。</p>
<p>现在，您可能想知道，为什么我们的use case以及我们的回调是一个接口？</p>
<p>为了更好地展示我们的下一个问题，让我们来研究_GetFeedArticlesUseCase_。</p>
<p>它需要一个feedId -&gt; 通过_FeedRespository_获取提要文章 -&gt; 返回提要文章</p>
<p>这里是数据流问题，用例介于表示层和数据层之间。 我们如何建立层之间的沟通？ 记住那些输入和输出端口？</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-4.png" alt="clean architecture"></p>
<p>我们的 Use Case必须实现输入端口（接口）。 Presenter在 Use Case上调用方法，数据流向 Use Case（feedId）。 Use Case映射feedId提供文章并希望将它们发送回表示层。 它有一个对输出端口（回调）的引用，因为输出端口是在同一层定义的，因此它调用了一个方法。 因此，数据发送到输出端口 - Presenter。</p>
<p>我们将稍微调整我们的UseCase契约类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UseCase</span>&lt;P, R&gt; &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Callback</span>&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(R return)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(P parameter, Callback&lt;R&gt; callback)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompletableUseCase</span>&lt;P&gt; &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(P parameter, Callback callback)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_UseCase_接口是输入端口，_Callback_接口是输出端口。</p>
<p>现在我们可以实现我们的_GetFeedArticlesUseCase_：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">GetFeedArticlesUseCase</span> <span class="keyword">implements</span> <span class="title class_">UseCase</span>&lt;Integer, List&lt;Article&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FeedRepository feedRepository;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> Integer feedId, <span class="keyword">final</span> Callback&lt;List&lt;Article&gt;&gt; callback)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback.onSuccess(feedRepository.getFeedArticles(feedId));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable throwable) &#123;</span><br><span class="line">      callback.onError(throwable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>让我们看看表示层如何使用我们的用例。 我们将创建一个_FeedArticlesPresenter_，它将使用我们的用例来获取文章并将它们显示在视图中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FeedArticlesPresenter</span> <span class="keyword">implements</span> <span class="title class_">UseCase</span>.Callback&lt;List&lt;Article&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> GetFeedArticlesUseCase getFeedArticlesUseCase;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ViewModelMapper viewModelMapper;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fetchFeedItems</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> feedId)</span> &#123;</span><br><span class="line">    getFeedArticlesUseCase.execute(feedId, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(<span class="keyword">final</span> List&lt;Article&gt; articles)</span> &#123;</span><br><span class="line">    getView().showArticles(viewModelMapper.mapArticlesToViewModels(articles));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="keyword">final</span> Throwable throwable)</span> &#123;</span><br><span class="line">    getView().showErrorMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，_FeedArticlesPresenter_实现了Callback接口，并将其自身传递给use case，它实际上是use case的输出端口，并以这种方式关闭了数据流。 这是我们前面提到的数据流的具体示例，我们可以在流程图上调整标签以匹配此示例：</p>
<p><img src="http://five.agency/wp-content/uploads/2016/11/Graph-5.png" alt="clean architecture"></p>
<p>我们的参数P是feedId，返回类型R是文章列表。</p>
<p>您不必使用Presenter来处理显示逻辑，我们可以说Clean架构是”前端”不可知的 - 这意味着您可以使用MVP，MVC，MVVM或其他任何东西。</p>
<h2 id="让我们在混合中抛出一些Rx"><a href="#让我们在混合中抛出一些Rx" class="headerlink" title="让我们在混合中抛出一些Rx"></a>让我们在混合中抛出一些Rx</h2><p>现在，如果你想知道为什么有这样的RxJava，我们将看看我们UseCase的反应式实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UseCase</span>&lt;P, R&gt; &#123;</span><br><span class="line">  Single&lt;R&gt; <span class="title function_">execute</span><span class="params">(P parameter)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompletableUseCase</span>&lt;P&gt; &#123;</span><br><span class="line">  Completable <span class="title function_">execute</span><span class="params">(P parameter)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回调接口现在不见了，我们使用RxJava Single &#x2F; Completable接口作为我们的输出端口。</p>
<p>Reactive <em>GetFeedArticlesUseCase</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GetFeedArticlesUseCase</span> <span class="keyword">implements</span> <span class="title class_">UseCase</span>&lt;Integer, List&lt;Article&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FeedRepository feedRepository;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Single&lt;List&lt;Article&gt;&gt; <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> Integer feedId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> feedRepository.getFeedArticles(feedId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reactive <em>FeedArticlePresenter</em> 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FeedArticlesPresenter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> GetFeedArticlesUseCase getFeedArticlesUseCase;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ViewModeMapper viewModelMapper;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fetchFeedItems</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> feedId)</span> &#123;</span><br><span class="line">    getFeedItemsUseCase.execute(feedId)</span><br><span class="line">      .map(feedViewModeMapper::mapFeedItemsToViewModels)</span><br><span class="line">      .subscribeOn(Schedulers.io())</span><br><span class="line">      .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">      .subscribe(<span class="built_in">this</span>::onSuccess, <span class="built_in">this</span>::onError);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(<span class="keyword">final</span> List articleViewModels)</span> &#123;</span><br><span class="line">    getView().showArticles(articleViewModels);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="keyword">final</span> Throwable throwable)</span> &#123;</span><br><span class="line">    getView().showErrorMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然它有点隐藏，但同样的数据流反演原理仍然存在，因为没有RxJava Presenters实现回调，并且RxJava订阅者也包含在外层 - 在Presenter的某处。</p>
<h2 id="Data-和-Device"><a href="#Data-和-Device" class="headerlink" title="Data 和 Device"></a>Data 和 Device</h2><p>Data和Device包含业务逻辑不关心的所有实现细节。 它只关心契约类，允许您轻松测试它并在不触及业务逻辑的情况下交换实施。</p>
<p>在这里，您可以使用自己喜欢的ORM或DAO在本地存储数据，并使用网络服务从网络获取数据。 我们将实现_FeedService_来获取文章，并使用_FeedDao_将文章数据存储在设备上。</p>
<p>每个数据源（网络和本地存储）都将有自己的模型可供使用。</p>
<p>在我们的例子中，它们是_ApiFeed_ - <em>ApiArticle_和_DbFeed</em> - <em>DbArticle</em>。</p>
<p>_FeedRepository_的具体实现也可以在Data模块中找到。</p>
<p>Device模块将持有作为_NotificationManager_类的包装的通知合同的实现。 我们也许可以使用业务逻辑中的通知来在用户可能感兴趣并推动参与的新文章发布时向用户显示通知。</p>
<h2 id="Models-models-everywhere"><a href="#Models-models-everywhere" class="headerlink" title="Models, models everywhere."></a>Models, models everywhere.</h2><p>您可能已经注意到我们提到的不仅仅是实体或业务模型，还有更多的模型。</p>
<p>实际上，我们也有db模型，API模型，View模型，当然还有业务模型。</p>
<p>对于每个图层来说，都有一个很好的实践，可以使用它自己的模型，因此具体的细节（如View）不依赖于较低层实现的具体细节。 这样，例如，如果您决定从一个ORM更改为另一个，则不必分解不相关的代码。</p>
<p>为了实现这一点，有必要在每个图层中使用对象映射器。 在示例中，我们使用_ViewModelMapper_将Domain 里的_Article_模型映射到_ArticleViewModel_。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遵循这些准则，我们创建了一个强大且多功能的架构。 起初，它可能看起来像很多代码，它有点像，但请记住，我们正在构建我们的架构以适应未来的变化和功能。 如果你做得对，未来你会感恩。</p>
<p>在下一部分中，我们将会介绍这个架构中最重要的部分，可测试性以及如何测试它。</p>
<p>那么，在此期间，您最感兴趣的是架构实现的哪一部分？</p>
<p>这是Android Architecture系列的一部分。 检查我们的其他部分：</p>
<p><span class="exturl" data-url="aHR0cDovL2ZpdmUuYWdlbmN5L2FuZHJvaWQtYXJjaGl0ZWN0dXJlLXBhcnQtNS10ZXN0LWNsZWFuLWFyY2hpdGVjdHVyZS8=">Part 5: How to Test Clean Architecture<i class="fa fa-external-link-alt"></i></span></p>
<p><a href="/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%9C%A8Android%E4%B8%8A%E5%BA%94%E7%94%A8Clean%E6%9E%B6%E6%9E%84-%E8%AF%91/">Part 3: Applying Clean Architecture on Android</a></p>
<p><a href="/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-The-clean-architecture-%E8%AF%91/">Part 2: The Clean Architecture</a></p>
<p><a href="/2018/05/07/Android%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%AF%8F%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%E9%83%BD%E5%BE%88%E8%89%B0%E9%9A%BE-%E8%AF%91/">Part 1: every new beginning is hard</a> </p>
]]></content>
      <categories>
        <category>Android架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Clean架构</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>三杯曼哈顿</title>
    <url>/2024/12/23/%E4%B8%89%E6%9D%AF%E6%9B%BC%E5%93%88%E9%A1%BF/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1735040736883-9e0bc7e6f1ba?q=80&w=1974&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA==" alt="曼哈顿"></p>
<p>那天晚上，我在深夜酒吧遇见了一个自称来自1984年的女人。<br>她穿着一件褪色的蓝色连衣裙，坐在吧台最角落的位置。<br>调酒师正在为她调制第三杯曼哈顿。<br>冰块在玻璃杯中碰撞，发出清脆的声响，像是某种暗号。</p>
<p>“你相信平行宇宙吗？”她突然问我。</p>
<span id="more"></span>

<p>没等我回答，她继续说：”在我的时空里，现在应该是凌晨3点17分。我的丈夫正在床上睡觉，而我在厨房里煮着咖啡。”<br>我看了看手表，现在正好是凌晨3点17分。<br>“真巧，”我说，”现在也是这个时间。”<br>她笑了，那种笑容让我想起了很久以前养过的一只猫。<br>那只猫在离开前的最后一个晚上，也是这样看着我。</p>
<p>“没什么巧合，”她说，”时间是个圆。就像这个杯子的边缘。”<br>她用手指轻轻划过酒杯的边缘，发出一声几不可闻的嗡鸣。</p>
<p>爵士乐还在继续。萨克斯风手似乎永远不会疲倦。<br>我注意到她左手无名指上有一道浅浅的戒指印，却没戴戒指。</p>
<p>“你丈夫知道你在这里吗？”我问。<br>“知道啊，”她说，”他在1984年的床上等我回去。但我想他已经习惯了。毕竟我每个星期四都会来这里，坐在这个位置，点三杯曼哈顿。”<br>“为什么是三杯？”<br>“第一杯是为了记住，第二杯是为了忘记，第三杯是为了在记住和忘记之间找到平衡。”<br>她说这话时，目光穿过我，望向某个我看不见的远方。</p>
<p>当她喝完第三杯酒，站起身准备离开时，我注意到她的影子却仍坐在吧台前。<br>她像是没有察觉，径直走向门口。<br>推开门的瞬间，一阵冷风吹进来，带着雨水的气息。</p>
<p>我转头看向她留下的座位。<br>她的影子已经消失了，只剩下三个空酒杯。<br>最后一个杯子里，冰块还在缓慢融化。</p>
<p>调酒师走过来收拾杯子，我问他：”那个女人经常来吗？”<br>“什么女人？”他一边擦拭吧台一边问。<br>我指了指角落的位置，那里现在空无一人，连杯子都不见了。<br>只有一滴水珠在木质台面上，映着头顶的灯光，闪烁着奇异的光芒。<br>外面开始下雨了。雨滴打在窗户上的声音，和1984年的某个夜晚，或许完全一样。</p>
]]></content>
      <categories>
        <category>短篇小说</category>
      </categories>
      <tags>
        <tag>AI短篇小说</tag>
        <tag>AI生成</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Android中执行TDD？ 第1部分 - 概述(译)</title>
    <url>/2018/05/27/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E4%B8%AD%E6%89%A7%E8%A1%8CTDD%EF%BC%9F%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E6%A6%82%E8%BF%B0(%E8%AF%91)/</url>
    <content><![CDATA[<p>Android自动化测试教程系列,使用JUnit＆Espresso</p>
<p>自动化测试非常重要，因为它在开发应用程序时确保了质量.TDD在编写实现之前执行写入测试。</p>
<p>有关TDD的更多信息，请参阅此前的教程。</p>
<span id="more"></span>

<h3 id="测试金字塔："><a href="#测试金字塔：" class="headerlink" title="测试金字塔："></a>测试金字塔：</h3><p>正如我们可以看到下面的金字塔：</p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*9LV9happxsb-UqmmnDk-Qw.png" alt="测试金字塔"></p>
<p><strong>单元测试</strong>涵盖了制作坚实基础的大部分金字塔。 单元测试很容易编写。</p>
<p><strong>集成测试</strong>确保模块的集成是正确的，并覆盖第二大块金字塔。</p>
<p><strong>功能测试</strong>通常描述系统在三部分中所做的并占据最小的部分。</p>
<p>有许多测试工具和框架可以在开发应用程序时使用。 其中一些是由Google提供和支持的，其中一些是第三方。</p>
<h3 id="Android中的测试类型："><a href="#Android中的测试类型：" class="headerlink" title="Android中的测试类型："></a>Android中的测试类型：</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>单元测试主要针对与其他组件隔离的最小功能（如方法，类，组件或小模块）。</p>
<p><em>用于单元测试的工具：</em></p>
<ul>
<li>JUnit是编写可重复测试的简单框架。 它是单元测试框架的xUnit体系结构的一个实例。</li>
<li>Robolectric是流行的Android单元测试框架，通过在JVM上运行测试（不需要任何设备或仿真器），可以加快测试的执行速度。</li>
</ul>
<h4 id="UI测试"><a href="#UI测试" class="headerlink" title="UI测试"></a>UI测试</h4><p>UI测试是模拟用户交互的测试，如单击按钮，在EditText中输入文本。 Android Instrumentation是Android系统中的一组”挂钩”，它允许您控制Android组件的生命周期（即自己驱动活动生命周期，而不是由系统驱动这些生命周期）。 这些测试需要运行实际的设备或仿真器。</p>
<p><em>用于UI测试的工具：</em></p>
<ul>
<li>Espresso - Google提供的Android UI测试框架，可以很好地处理测试同步。</li>
<li>UIAutomator - Google提供的Android UI测试框架，用于同时测试多个应用程序。</li>
<li>Robotium - 第三方Android UI测试框架（Robotium vs Espresso）</li>
<li>Selendroid - Selenium for Android</li>
</ul>
<h4 id="项目测试目录结构"><a href="#项目测试目录结构" class="headerlink" title="项目测试目录结构"></a>项目测试目录结构</h4><p>在我们的项目中，两个文件夹托管我们的测试，这些测试是test和androidTest。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*64ZYn-MpgqAMAwXaWNHdFA.png" alt="测试目录结构"></p>
<p><strong>test</strong>：单元测试托管在此文件夹中。 这些测试在JVM上运行，不需要Android设备或模拟器。 这种类型的测试无法访问任何Android框架特定的组件，如上下文。</p>
<p><strong>androidTest</strong>： - 所有Instrumentation（Espresso）测试托管在此文件夹中。这些测试需要物理Android设备或模拟器才能运行。</p>
<p>在下一篇文章中，我们将深入探讨遵循和执行单元测试的体系结构。</p>
<p>同时，希望听到有关这方面的建议和意见。</p>
<p>干杯🍻!!! </p>
]]></content>
      <categories>
        <category>Android测试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>译文</tag>
        <tag>TDD</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Android中执行TDD？ 第2部分 - 项目体系结构，设置和单元测试(译)</title>
    <url>/2018/06/03/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E4%B8%AD%E6%89%A7%E8%A1%8CTDD%EF%BC%9F%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E9%A1%B9%E7%9B%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%8C%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95(%E8%AF%91)/</url>
    <content><![CDATA[<p>原文</p>
<p>本教程将通过项目体系结构，从头开始设置，最后我们将编写一些单元测试。</p>
<p>而本系列的第1部分，我们介绍了什么是自动化测试的重要性，什么是测试金字塔，什么是测试类型，可以使用什么工具在Android中执行TDD以及测试文件夹的位置。</p>
<span id="more"></span>

<h3 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h3><p>根据自动化测试，我们必须遵循某种架构模式，这将有助于我们以清晰，可测试的方式测试和构建应用程序。</p>
<p>有许多架构模式可轻松支持TDD Model - View - Presenter（MVP），Model - View - Viewmodel（MVVM）。</p>
<p><strong>我们正在为我们的教程系列选择MVP。</strong></p>
<ol>
<li><strong>Model</strong>通常是由Presenter和View用来传达信息或采取行动的POJO。</li>
<li><strong>View</strong>（Activity或Fragment）是显示数据的被动界面。这是我们设置数据并进行UI相关更改（如隐藏，移动视图）的地方。</li>
<li><strong>Presenter</strong>决定演示逻辑，我们的业务逻辑驻留在这里。 它与存储库交谈获取数据，并将其格式化以显示在视图中。 它决定在View.Try上显示什么，尽量避免在演示者中使用Android特定的代码（我知道有时更难）。</li>
</ol>
<h3 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h3><p>在这篇文章中，我们将从头开始创建简单的Android应用程序。 我们将创建的应用程序是简单的应用程序，登录并采取学生出席。</p>
<ol>
<li>打开Android Studio选择”<strong>Start a new Android Project</strong>“</li>
<li>输入应用程序名称为”<strong>StudentAttendance</strong>“，公司域名为”<strong>nilesh.tdd.com</strong>“。 点击下一步<br><img src="https://cdn-images-1.medium.com/max/800/1*dpnE8qzqmPToc7-nwYTQXA.png" alt="创建项目"></li>
<li>选择你想要支持的Android版本并点击”<strong>Next</strong>“<br><img src="https://cdn-images-1.medium.com/max/800/1*OAM95sofW0ggruqfKFteJA.png" alt="选择Android版本"></li>
<li>选择”<strong>Empty Activity</strong>“并点击”<strong>Next</strong>“<br><img src="https://cdn-images-1.medium.com/max/800/1*OAM95sofW0ggruqfKFteJA.png" alt="选择Empty Activity"></li>
<li>输入活动名称，然后单击”<strong>Finish</strong>“<br><img src="https://cdn-images-1.medium.com/max/800/1*OAM95sofW0ggruqfKFteJA.png" alt="输入活动名称"></li>
<li>最终的项目结构将如下图所示<br><img src="https://cdn-images-1.medium.com/max/800/1*OAM95sofW0ggruqfKFteJA.png" alt="项目结构"></li>
</ol>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>在对包结构进行一些重构之后，签出提交(<strong>81d1668667bcb5eacf4cf94a8dffe738ad206d67</strong>)</p>
<p><strong>使用下面的命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NileshJarad/TDD_Demo.git</span><br><span class="line">git checkout 81d1668667bcb5eacf4cf94a8dffe738ad206d67</span><br></pre></td></tr></table></figure>

<p>如果有人在结帐后出现错误<br><img src="https://cdn-images-1.medium.com/max/800/1*lfKyDU02BXRo1B-7Ul7BnQ.png" alt="结帐错误"><br>然后在build.gradle中将build.gradle版本更改为2.1.2<br><img src="https://cdn-images-1.medium.com/max/800/1*kja_Shq18OXShIX2xPkBXw.png" alt="build.gradle"><br>所以最后我们在这里编程了。</p>
<p>现在我们将编写我们的第一个测试用例来检查”<strong>如果用户在三次尝试后尝试登录，我们会向他&#x2F;她显示错误消息</strong>“</p>
<p>转到<strong>com.tdd.nilesh.studentattendance.login.LoginPresenter</strong>类。 在类名上使用光标，按<strong>SHIFT + CTRL + T</strong>（对于mac <strong>SHIFT + CMD + T</strong>），这将弹出带有Create New Test选项的窗口。<br><img src="https://cdn-images-1.medium.com/max/800/1*UMhQkMxos0hS06TBYGw7Xg.png" alt="创建测试"><br>它将自动为Test选择类名，并在我们的例子<strong>LoginPresenterTest</strong>的类名末尾追加Test。<br><img src="https://cdn-images-1.medium.com/max/800/1*mRhJiRo7wye4X0Ojj2qixw.png" alt="创建测试"><br>点击确定。 它会再次弹出窗口的测试文件夹。 在我们编写JUnit时，请选择..&#x2F;app&#x2F;src&#x2F;test&#x2F;…它将创建具有相同包结构的测试类。<br><img src="https://cdn-images-1.medium.com/max/800/1*j5pa8aebCAGyLKWLpxbwdg.png" alt="创建测试"></p>
<p>我正在发布代码的快照，因为我希望您编写代码。😊<br>现在我们将写下如下屏幕截图中的测试。<br><img src="https://cdn-images-1.medium.com/max/800/1*-wz1hC51x6wRkqA7OJAcTA.png" alt="创建测试"><br><strong>@Test</strong>注释表明它是测试。 由于<strong>incrementLoginAttempt</strong>＆<strong>isLoginAttemptExceeded</strong>以红色显示。 我们必须在<strong>LoginPresenter</strong>中创建方法。 按<strong>ALT + ENTER</strong>，将在演示者类中创建方法，如下所示。<br><img src="https://cdn-images-1.medium.com/max/800/1*3sOPDcwW7eXa6yv2RDFDMw.png" alt="创建测试"></p>
<p>我们写了失败的测试。 逐渐我们会为它编写它的实现。 要运行测试，请按测试名称左侧的小绿色播放图像。<br><img src="https://cdn-images-1.medium.com/max/800/1*VlQnTHDvgvRdt3wFl2LeWg.png" alt="运行测试"><br>由于我们编写的测试失败测试输出应如下所示。<br>我们期待1作为输出，但我们得到0。<br><img src="https://cdn-images-1.medium.com/max/800/1*ugRLt-KJZu9NogmwYGgGNQ.png" alt="运行测试"><br>现在我们将编写通过测试的测试实现。 以下是通过测试的实施。<br><img src="https://cdn-images-1.medium.com/max/800/1*yq0xP22HkiBto1ZK4edQCw.png" alt="通过测试"></p>
<p>再次运行测试它应该传递😍。<br><img src="https://cdn-images-1.medium.com/max/800/1*wCriHjd_c72e7I3Xv54Y4A.png" alt="通过测试"><br>直到现在，使用以下结帐命令进行回购。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 302962ea6f63aa3afba003efa043ebacbaf02345</span><br></pre></td></tr></table></figure>

<p>现在您必须编写<strong>checkIfLoginAttemptIsNotExceeded</strong>测试，并检查您的实现是否正确。 如果你不是，不要担心它会在下一次提交。</p>
<p>现在我们要检查”用户名和密码是否正确”</p>
<p>所以我们会写测试，下面是它的样子（失败测试😉）<br><img src="https://cdn-images-1.medium.com/max/800/1*JaeEY0mdhu4ytUzi9_nD-Q.png" alt="失败测试"><br>再次重复<strong>ALT + ENTER</strong>和运行测试的过程。 由于测试失败，它会显示红色警报失败。</p>
<p>现在我们将编写它的实现如下。<br><img src="https://cdn-images-1.medium.com/max/800/1*xAkaUJiXA_At67-R0092Xg.png" alt="通过测试"><br>再次运行测试它现在会通过。</p>
<p>现在尝试使用<strong>checkUsernameAndPasswordIsInCorrect</strong>测试用例。</p>
<p>直到现在，使用以下结帐命令进行回购。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 4771fbfb8c6cbda98d9f01ac5e035ea02f0f5da6</span><br></pre></td></tr></table></figure>

<p>同时，希望听到有关这方面的建议和意见。</p>
<p>干杯🍻!!! </p>
]]></content>
      <categories>
        <category>Android测试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>译文</tag>
        <tag>TDD</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>我以为找到了AI开发的“圣杯”，结果差点被Token账单劝退……直到我悟了</title>
    <url>/2025/09/18/%E6%88%91%E4%BB%A5%E4%B8%BA%E6%89%BE%E5%88%B0%E4%BA%86AI%E5%BC%80%E5%8F%91%E7%9A%84%E2%80%9C%E5%9C%A3%E6%9D%AF%E2%80%9D%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%B7%AE%E7%82%B9%E8%A2%ABToken%E8%B4%A6%E5%8D%95%E5%8A%9D%E9%80%80%E2%80%A6%E2%80%A6%E7%9B%B4%E5%88%B0%E6%88%91%E6%82%9F%E4%BA%86/</url>
    <content><![CDATA[<h2 id="那个让我热血沸腾的下午"><a href="#那个让我热血沸腾的下午" class="headerlink" title="那个让我热血沸腾的下午"></a>那个让我热血沸腾的下午</h2><p>我至今还记得第一次看到 CCPM (<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F1dG9tYXplaW8vY2NwbQ==">https://github.com/automazeio/ccpm<i class="fa fa-external-link-alt"></i></span>) 项目的那个下午。</p>
<p>看到这个项目 GitHub 上 4.7K 个 star，心想：妥了！</p>
<p>屏幕上，一行行命令被敲下，AI智能体（Agent）像一支训练有素的特种部队，自动分析需求、创建任务、并行处理开发……一切井然有序，充满了未来感。</p>
<p>我当时的感觉，就像是寻觅多年的屠龙刀终于现世。我激动地拍着大腿，告诉自己：就是它了，敏捷开发的终极答案！纯 AI 口喷代码要升级为自动化开发了！！！</p>
<p>我摩拳擦掌，立刻在自己的项目里部署了这套系统，准备大干一场。我幻想着，从此以后，我只需要提出需求，我的“AI军团”就会夜以继日地为我工作，交付完美的代码。</p>
<p>然而，我没高兴太久。两天后，一个残酷的现实几乎把我从云端拽回了地面。</p>
<h2 id="踩坑实录：我的“AI军团”怎么成了一群“金鱼”？"><a href="#踩坑实录：我的“AI军团”怎么成了一群“金鱼”？" class="headerlink" title="踩坑实录：我的“AI军团”怎么成了一群“金鱼”？"></a>踩坑实录：我的“AI军团”怎么成了一群“金鱼”？</h2><p>一开始还算顺利，但很快，问题就一个接一个地冒了出来。</p>
<p>我让Claude Code 开发一个AI 小说编译器，一开始用 GPT-5 生成的 PRD（大家都说 GPT-5 计划能力比 Claude 强，适合做架构师），CCPM一顿输出，在 GitHub 项目里生成了一堆 Issue，开始生成一堆开发流的子代理开始深入开发，我发现每个开发流开发的代码都比较差强人意。</p>
<p>更要命的是，它们好像都患上了“短期失忆症”，记忆力跟金鱼差不多，只有7秒。</p>
<p>每一次启动一个子任务，它都得把所有的项目资料、代码规范、需求文档重新读一遍。</p>
<p>我感觉自己不像个运筹帷幄的指挥官，倒像个絮絮叨叨的老妈子，跟在一群健忘的机器人屁股后面，一遍遍重复着：“这是需求文档，拿去看！”，“这是代码规范，别忘了！”，“刚刚那个API是这么定义的，你倒是记一下啊！”</p>
<p><img src="https://resv2.craft.do/user/full/86216952-a1bc-6ff4-661b-46aa5fdbb1d4/doc/29BF2A0D-BD4D-4A0D-80A9-F6C63A2BF1CB/1E4C54A8-9397-435E-84A1-A1E463DC6021_2/wYwBOru9vegZRsTkf1stplWG9CDenzQE5ekNcIlc1ycz/Image.png" alt="Image.png"></p>
<span id="more"></span>

<p>这种“失忆”的代价是巨大的。</p>
<p>那天，我怀着忐忑的心情点开了我的Token账单，心瞬间凉了半截。那串不断跳动的数字狠狠地告诉我：我的“AI军团”主要工作不是在写代码，而是在烧钱。</p>
<p>每一次“失忆”，都是一次昂贵得离谱的上下文重复加载。</p>
<p>我第一次对AI自动化的前景产生了怀疑。这条路，真的走得通吗？至少以这种方式，肯定走不通。</p>
<p>后面我查到，Claude Code 子代理（Sub-agent）与主代理的上下文不共享。为了完成任务，子代理需要反复查询和加载项目资料，导致上下文信息重复、混乱且极易丢失。</p>
<p>上下文的反复加载，使得每一次调用都成本高昂，让自动化流程在经济上变得不可行。</p>
<h2 id="坑底的思考：问题不在AI，在“管理模式”"><a href="#坑底的思考：问题不在AI，在“管理模式”" class="headerlink" title="坑底的思考：问题不在AI，在“管理模式”"></a>坑底的思考：问题不在AI，在“管理模式”</h2><p>碰壁之后，我冷静了一下。我关掉IDE，开始复盘。</p>
<p>我问自己一个问题：如果这是一个真人团队，我会怎么管理？</p>
<p>我绝不会找来10个刚毕业的实习生，把他们关在一个会议室里，扔给他们一堆文档，然后说“你们开始干活吧，自由发挥”。那只会是一场灾难。</p>
<p>一个高效的团队，必然有清晰的层级和分工。</p>
<p>这时，我脑子里闪过一道光，瞬间想通了。</p>
<p>CCPM那一套并行模式，像什么呢？</p>
<p>虽然项目名称叫做 PM，但是它却像一个没有项目经理的“扁平化委员会”。每个AI Agent都是平等的成员，信息共享基本靠吼（反复读取公共资料），最终导致信息过载、责任不清、效率低下。</p>
<p>我真正需要的，应该是什么呢？</p>
<p>我需要一个“高效指挥部”！必须有一个唯一的项目经理（PM），他掌握所有信息和最终决策权。团队其他成员都是领域专家（前端、后端、测试等）。专家们接任务、做研究、写分析报告，然后把报告统一交给PM来整合和执行。专家不需要、也不应该知道项目的全部细节，那只会干扰他们的专业判断。</p>
<p>这个“指挥官-专家”模式，就是我找到的答案！我立刻为我的AI团队重新制定了铁律：</p>
<p>唯一的“指挥官”: 必须有一个主Agent，它独占所有“写”权限，是唯一的代码“操盘手”，手握最终代码库的写入权限。<br>专注的“专家们”: 其他所有子Agent，都降级为“研究员”和“规划师”。它们只负责思考和写文档（比如需求分析、技术方案），然后把报告交上来。它们不准碰代码。<br>这样一来，上下文永远是统一的，“指挥官”拥有最完整的记忆。Token成本也瞬间降低，因为不再需要反复加载那昂贵的基础信息了。</p>
<p><img src="https://resv2.craft.do/user/full/86216952-a1bc-6ff4-661b-46aa5fdbb1d4/doc/29BF2A0D-BD4D-4A0D-80A9-F6C63A2BF1CB/CFF5F8C2-5C09-4775-81D9-94BF6ACD00BE_2/4ODCvczKXZoDb62fm5yic9EXb31MbxgvsTZyjxfBTE4z/Image.png" alt="Image.png"></p>
<h2 id="动手开干：打造我的“AI开发流水线”cc-devflow"><a href="#动手开干：打造我的“AI开发流水线”cc-devflow" class="headerlink" title="动手开干：打造我的“AI开发流水线”cc-devflow"></a>动手开干：打造我的“AI开发流水线”<code>cc-devflow</code></h2><p>有了新思路，我立刻开始敲代码。</p>
<p>这一次，我的目标不再是造一个更聪明的AI，而是设计一套更聪明的“工作流程”。我要让开发者真正成为指挥官，只需要下达一个命令，剩下的交给这条自动流水线。</p>
<p>我把它命名为<code>cc-devflow</code>。</p>
<p>它的核心，就是那套“指挥部”规矩，我把它变成了真实可用的代码：</p>
<h3 id="一行命令的魔法：-flow-new"><a href="#一行命令的魔法：-flow-new" class="headerlink" title="一行命令的魔法：/flow-new"></a>一行命令的魔法：<code>/flow-new</code></h3><p>过去，启动一个复杂任务需要敲一连串命令。现在，你只需要在终端输入：<br><code>/flow-new &quot;REQ-123|用户下单支持&quot;</code><br>这就像你走到AI项目经理“老王”的工位，把需求文档拍在他桌上说：“老王，这个需求你跟一下，从头到尾。” 简单、直接。</p>
<h3 id="透明的进度条：-flow-status"><a href="#透明的进度条：-flow-status" class="headerlink" title="透明的进度条：/flow-status"></a>透明的进度条：<code>/flow-status</code></h3><p>项目开始后，你随时可以像老板一样，问一句：“老王，那事儿到哪一步了？”<br><code>/flow-status REQ-100 --detailed</code><br>他会立刻给你一份清晰的进度报告，告诉你需求分析、任务拆解、编码、测试分别进行到哪个阶段了，绝不藏着掖着。</p>
<h3 id="不怕掉线的安全感：-flow-restart"><a href="#不怕掉线的安全感：-flow-restart" class="headerlink" title="不怕掉线的安全感：/flow-restart"></a>不怕掉线的安全感：<code>/flow-restart</code></h3><p>最让我安心的是这个功能。就算开发过程中电脑蓝屏了、网络断了，你都不用慌。回来后，只需对“老王”说一声：<br><code>/flow-restart &quot;REQ-100</code>”<br>他就能立刻从上次中断的地方接着干，绝不会把做过的工作再做一遍，更不会忘记自己干到哪了。</p>
<p><img src="https://resv2.craft.do/user/full/86216952-a1bc-6ff4-661b-46aa5fdbb1d4/doc/29BF2A0D-BD4D-4A0D-80A9-F6C63A2BF1CB/81392339-353C-49EC-B8E7-F718C93DEBFF_2/2cKAn5I1kSRcKyAvUdBKhOzdiIbXbQq8Zb1mxMbCeUwz/Image.png" alt="Image.png"></p>
<p>当我终于用<code>cc-devflow</code>完整地跑通第一个需求，看着屏幕上自动弹出的GitHub Pull Request创建成功的通知时，我知道，我成功了。</p>
<p>五、我的新角色：从“码农”到AI“产品经理”<br>这次经历，彻底改变了我对未来工作的看法。我意识到，我的工作性质，可能永远地改变了。</p>
<p>我不再是那个埋头写每一行代码的人了。</p>
<p>我的价值，不再是“写得快不快”，而是“想得清不清楚”。我需要把需求定义得无比清晰，这样我的AI团队才能正确地理解和执行。</p>
<p>我大部分的时间，开始花在设计和优化<code>.claude/agents/</code>目录下的那些提示词（Prompt）和工作流程（SOP）上，就像在为我的AI员工们编写岗位说明书和培训手册。</p>
<p>我成为了我自己的AI团队的“产品经理”和“流程架构师”。</p>
<p>这并不可怕，相反，这很酷。它把我们从重复的、机械的体力劳动中解放出来，去做更具创造性和战略性的思考。你，准备好成为AI的管理者了吗？</p>
<h2 id="写在最后：这不是终点，而是我们共同的起点"><a href="#写在最后：这不是终点，而是我们共同的起点" class="headerlink" title="写在最后：这不是终点，而是我们共同的起点"></a>写在最后：这不是终点，而是我们共同的起点</h2><p>故事讲到这里，也该结尾了。</p>
<p>我把<code>cc-devflow</code>这个项目，连同我所有的思考和踩坑经验，都开源了。</p>
<p>GitHub链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RpbW9uOTQvY2MtZGV2Zmxvdw==">https://github.com/Dimon94/cc-devflow<i class="fa fa-external-link-alt"></i></span></p>
<p>因为我踩过的坑，不希望你再踩一遍。这条探索之路，我一个人走很辛苦，但如果有一群志同道合的人一起走，或许能走得更快、更远。</p>
<p>你可以通过下面这行简单的命令，立刻“认领”你自己的AI开发团队：<br><code>npx tiged Dimon94/cc-devflow/.claude .claude</code></p>
<p>如果你对这个项目有任何想法，或者你也有自己的“踩坑故事”，都非常欢迎来GitHub的Issue里分享。<code>cc-devflow</code>不是一个完美的终点，而是我们共同探索AI协作新范式的起点。</p>
]]></content>
      <categories>
        <category>AI研习录</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Android中执行TDD？第4部分 - 使用Espresso进行UI测试(译)</title>
    <url>/2018/06/10/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E4%B8%AD%E6%89%A7%E8%A1%8CTDD%EF%BC%9F%E7%AC%AC4%E9%83%A8%E5%88%86%20-%20%E4%BD%BF%E7%94%A8Espresso%E8%BF%9B%E8%A1%8CUI%E6%B5%8B%E8%AF%95(%E8%AF%91)/</url>
    <content><![CDATA[<p>原文</p>
<p>在这篇文章中，我们将介绍什么是Espresso，Espresso提供了什么API，如何编写UI测试。</p>
<h3 id="什么是Espresso"><a href="#什么是Espresso" class="headerlink" title="什么是Espresso ?"></a><strong>什么是Espresso ?</strong></h3><p>Espresso正在为谷歌测试用于UI测试的框架。 它为单一应用程序中的UI测试提供了API。 用户界面测试可确保用户交互不良或遇到意外行为。</p>
<blockquote>
<p>我知道你现在习惯于为你的代码编写测试（至少这是我对你的<strong>期望）。</strong></p>
</blockquote>
<span id="more"></span>

<p>Espresso主要的三个类</p>
<ol>
<li><strong>ViewMatcher</strong>：用于使用onView（）在UI上查找视图</li>
<li><strong>ViewActions</strong>：用户使用ViewInteraction.perform（）对UI元素执行操作</li>
<li><strong>ViewAssertion</strong>：用于使用ViewInteraction.check（）来断言视图</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.my_view))      <span class="comment">// withId(R.id.my_view) is a ViewMatcher</span></span><br><span class="line">    .perform(click())             <span class="comment">// click() is a ViewAction</span></span><br><span class="line">    .check(matches(isDisplayed())); <span class="comment">// matches(isDisplayed()) is a ViewAssertion</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在LoginActivity上按SHIFT + CTRL + T并在androidTest文件夹中为UI测试创建测试类。</p>
</blockquote>
<p>在类名上创建@RunWith（AndroidJUnit4.class）之后</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*nSDNz81yNzMoZv9ATHni6Q.png" alt="创建测试类"></p>
<p>现在我们用@Test注解编写测试<strong>checkUserNameEditTextIsDisplayed（）</strong>。 我们还需要ActivityTestRule。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*TXmipgWmUgbRjSKIua5qSA.png" alt="编写测试"></p>
<p>在<strong>checkUserNameEditTextIsDisplayed（）<strong>中我们检查的是用户名</strong>EditText</strong>显示在UI上。</p>
<p><em>Espresso 的方法是自我解释的。</em></p>
<p>运行它将通过的测试（对于运行测试，我们需要仿真器或实际设备，因为这是UI测试）。</p>
<p>现在尝试使用户编辑文本的可见性消失，并再次运行测试失败。</p>
<p>现在我们测试点击空白字段的登录按钮，并检查是否显示错误消息。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*dimJrtNfxgNzRWqqY6dHmg.png" alt="测试空白字段"></p>
<p>运行测试正在通过。</p>
<p>接下来我们将为登录成功编写测试。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*7utZHMwuzuac8WaoDLr0jA.png" alt="测试登录成功"></p>
<p>干杯！🍺🍺🍺。 我们已经完成了基本的测试。 测试中还有很多需要探索的地方。</p>
<p>希望听到你的建议，对这个系列或帖子的投入<br>如果你喜欢关于TDD的系列，请将其推荐给其他人。<br>欲了解更多信息，请在Medium上关注我。 </p>
]]></content>
      <categories>
        <category>Android测试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>译文</tag>
        <tag>TDD</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>让你的Daggers保持锋利⚔️（译）</title>
    <url>/2018/08/26/%E8%AE%A9%E4%BD%A0%E7%9A%84Daggers%E4%BF%9D%E6%8C%81%E9%94%8B%E5%88%A9%E2%9A%94%EF%B8%8F%EF%BC%88%E8%AF%91%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：Keeping the Daggers Sharp ⚔️</p>
<p>原文作者：Py ⚔</p>
<p>译文出自：Dimon’s Program Basement</p>
<p>译者：Dimon</p>
</blockquote>
<p>Dagger2是一个非常好的依赖注入库，但是其<code>锋利的边缘</code>处理起来也是比较棘手的。这就让我们来看看Square公司通过遵循哪些最佳事件来防止工程师们<code>伤害自己</code>！</p>
<p><img src="https://cdn-images-1.medium.com/max/1800/1*5fsp9x_JcuJijFVotF1NQA.png" alt="Dagger2"></p>
<span id="more"></span>

<h3 id="与直接注入成员变量相比推荐通过构造函数注入"><a href="#与直接注入成员变量相比推荐通过构造函数注入" class="headerlink" title="与直接注入成员变量相比推荐通过构造函数注入"></a>与直接注入成员变量相比推荐通过构造函数注入</h3><ul>
<li>直接注入成员变量要求为非<code>final</code>字段且非<code>private</code>字段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CardConverter</span> &#123;</span><br><span class="line">  <span class="meta">@Inject</span> PublicKeyManager publicKeyManager;</span><br><span class="line">  <span class="meta">@Inject</span> <span class="keyword">public</span> <span class="title function_">CardConverter</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>忘记加上<code>@Inject</code>会导致<code>NullPointerException</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CardConverter</span> &#123;</span><br><span class="line">  <span class="meta">@Inject</span> PublicKeyManager publicKeyManager;</span><br><span class="line">  Analytics analytics; <span class="comment">// Oops, forgot to @Inject</span></span><br><span class="line">  <span class="meta">@Inject</span> <span class="keyword">public</span> <span class="title function_">CardConverter</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数注入是更好的方式，因为它允许<code>不可变</code>并且保证<code>线程安全</code>的对象没有部分构造的状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GOOD</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CardConverter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PublicKeyManager publicKeyManager;</span><br><span class="line">  <span class="meta">@Inject</span> <span class="keyword">public</span> <span class="title function_">CardConverter</span><span class="params">(PublicKeyManager publicKeyManager)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.publicKeyManager = publicKeyManager;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Kotlin消除了构造函数的注入样板：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CardConverter</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> publicKeyManager: PublicKeyManager)</span><br></pre></td></tr></table></figure>

<ul>
<li>我们依旧对系统构造的对象使用成员变量注入，比如Android Activities:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(MainActivity activity)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Inject</span> ToastFactory toastFactory;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> SquareApplication.component(<span class="built_in">this</span>);</span><br><span class="line">    component.inject(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例应该非常罕见"><a href="#单例应该非常罕见" class="headerlink" title="单例应该非常罕见"></a>单例应该非常罕见</h3><ul>
<li>当我们需要<strong>集中访问可变状态</strong>时，单例很有用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GOOD</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BadgeCounter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;Integer&gt; badgeCount;</span><br><span class="line">  <span class="meta">@Inject</span> <span class="keyword">public</span> <span class="title function_">BadgeCounter</span><span class="params">(...)</span> &#123;</span><br><span class="line">     badgeCount = ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果一个对象没有可变状态时，则不需要是单例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BAD, should not be a singleton!</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealToastFactory</span> <span class="keyword">implements</span> <span class="title class_">ToastFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Application context;</span><br><span class="line">  <span class="meta">@Inject</span> <span class="keyword">public</span> <span class="title function_">RealToastFactory</span><span class="params">(Application context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.context = context;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Toast <span class="title function_">makeText</span><span class="params">(<span class="type">int</span> resId, <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Toast.makeText(context, resId, duration);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在极少数情况下，我们使用作用域来<code>缓存</code>创建成本高昂的实例或者重复创建和丢弃的实例。（译者注：这也是为了让你更少的通过Dagger实现单例，因为实现太简单，可能导致滥用单例。）</li>
</ul>
<h3 id="与＠Provides相比更推荐＠Inject"><a href="#与＠Provides相比更推荐＠Inject" class="headerlink" title="与＠Provides相比更推荐＠Inject"></a>与<code>＠Provides</code>相比更推荐<code>＠Inject</code></h3><ul>
<li><code>@Provides</code>方法不应该复制构造函数样板。</li>
<li>当所有耦合问题都集中在一个地方的时候，代码更具可读性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ToastModule</span> &#123;</span><br><span class="line">  <span class="comment">// BAD, remove this binding and add @Inject to RealToastFactory</span></span><br><span class="line">  <span class="meta">@Provides</span> RealToastFactory <span class="title function_">realToastFactory</span><span class="params">(Application context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RealToastFactory</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这对于<code>单例</code>尤为重要，这是你在阅读这个类的时候需要了解的关键实现细节（<strong>implementation detail</strong>）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GOOD, I have all the details I need in one place.</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BadgeCounter</span> &#123;</span><br><span class="line">  <span class="meta">@Inject</span> <span class="keyword">public</span> <span class="title function_">BadgeCounter</span><span class="params">(...)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="推荐static修饰-Provides方法"><a href="#推荐static修饰-Provides方法" class="headerlink" title="推荐static修饰@Provides方法"></a>推荐<code>static</code>修饰<code>@Provides</code>方法</h3><ul>
<li>Dagger<code>@Provides</code>方法能够<code>static</code>修饰。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ToastModule</span> &#123;</span><br><span class="line">  <span class="meta">@Provides</span></span><br><span class="line">  <span class="keyword">static</span> ToastFactory <span class="title function_">toastFactory</span><span class="params">(RealToastFactory factory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成的代码可以直接调用该方法，而不必创建Module实例。该方法调用可以由编译器内联。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Generated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DaggerAppComponent</span> <span class="keyword">extends</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> ToastFactory <span class="title function_">toastFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ToastModule.toastFactory(realToastFactoryProvider.get())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个静态方法不会有太大变化，但所有绑定都是静态的，会导致相当大的性能提升。</li>
<li>试你的模块变得抽象并且如果其中一个<code>@Provides</code>方法不是静态的，那么在编译时<code>Dagger</code>会失败。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ToastModule</span> &#123;</span><br><span class="line">  <span class="meta">@Provides</span></span><br><span class="line">  <span class="keyword">static</span> ToastFactory <span class="title function_">toastFactory</span><span class="params">(RealToastFactory factory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与＠Provides相比更推荐＠Binds"><a href="#与＠Provides相比更推荐＠Binds" class="headerlink" title="与＠Provides相比更推荐＠Binds"></a>与<code>＠Provides</code>相比更推荐<code>＠Binds</code></h3><ul>
<li>当您将一种类型映射到另一种类型时，<code>@Binds</code>会替换<code>@Provides</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ToastModule</span> &#123;</span><br><span class="line">  <span class="meta">@Binds</span></span><br><span class="line">  <span class="keyword">abstract</span> ToastFactory <span class="title function_">toastFactory</span><span class="params">(RealToastFactory factory)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该方法必须是抽象的。它永远不会被调用；生成的代码将知道直接使用该实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Generated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DaggerAppComponent</span> <span class="keyword">extends</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">DaggerAppComponent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">this</span>.toastFactoryProvider = (Provider) realToastFactoryProvider;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> ToastFactory <span class="title function_">toastFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> toastFactoryProvider.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="避免在接口绑定上使用-Singleton"><a href="#避免在接口绑定上使用-Singleton" class="headerlink" title="避免在接口绑定上使用@Singleton"></a>避免在接口绑定上使用<code>@Singleton</code></h3><blockquote>
<p>Statefulness is an implementation detail</p>
</blockquote>
<ul>
<li>只有实现才知道他们是否需要确保集中访问的可变状态。</li>
<li>将实现绑定到接口时，不应该有任何作用域注释。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ToastModule</span> &#123;</span><br><span class="line">  <span class="comment">// BAD, remove @Singleton</span></span><br><span class="line">  <span class="meta">@Binds</span> <span class="meta">@Singleton</span></span><br><span class="line">  <span class="keyword">abstract</span> ToastFactory <span class="title function_">toastFactory</span><span class="params">(RealToastFactory factory)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启用error-prone"><a href="#启用error-prone" class="headerlink" title="启用error-prone"></a>启用error-prone</h3><p>几个Square团队正在使用它将常见的Dagger错误检查出来。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>这些指导原则适用于我们：小型异构团队在大型共享Android代码库上工作。由于您的背景可能不同，因此您应该应用对您的团队最有意义的内容。</p>
<p><strong>轮到你了！您遵循哪些良好做法来保持Dagger代码的清晰度？</strong> </p>
]]></content>
      <categories>
        <category>Dependency Injection</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>译文</tag>
        <tag>Dagger2</tag>
        <tag>Dependency Injection</tag>
        <tag>Best Practices</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Android中执行TDD？第3部分 - 模拟和集成测试(译)</title>
    <url>/2018/06/09/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E4%B8%AD%E6%89%A7%E8%A1%8CTDD%EF%BC%9F%E7%AC%AC3%E9%83%A8%E5%88%86%20-%20%E6%A8%A1%E6%8B%9F%E5%92%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95(%E8%AF%91)/</url>
    <content><![CDATA[<p>原文</p>
<p>很久以后，这是系列的第三篇教程。 我希望你们都做得很好，享受教程系列（阅读，编码和改进）。</p>
<p>到目前为止，在本系列的第1部分和第2部分，为什么开发人员害怕重构代码，我们获得了为什么TDD至高无上，Android测试的类型，测试的位置，如何编写和运行测试等。</p>
<p>我们覆盖了单元测试到现在，接下来我们将转向集成测试，以验证演示者是否应对UI。</p>
<p>如图所示，我们可以创建用于登录的用户界面（我知道你会比这更好的用户界面）。</p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*pFyDEdZTg8DFVbsIml9OIQ.jpeg" alt="登录界面"></p>
<span id="more"></span>

<p>所以我们将编写一些与UI相关的代码。 我们在View和Presenter之间签有合同，即LoginView，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginView</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showLoginSuccessMessage</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showLoginFailedMessage</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showLoginAttemptExceededMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们将LoginView实现为我们的Activity，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">LoginView</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EditText usernameEditText;</span><br><span class="line">    <span class="keyword">private</span> EditText passwordEditText;</span><br><span class="line">    <span class="keyword">private</span> Button loginButton;</span><br><span class="line">    <span class="keyword">private</span> LoginPresenter loginPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_login);</span><br><span class="line">        loginPresenter = <span class="keyword">new</span> <span class="title class_">LoginPresenter</span>();</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initView</span><span class="params">()</span> &#123;</span><br><span class="line">        usernameEditText = (EditText) findViewById(R.id.username_edit_text);</span><br><span class="line">        passwordEditText = (EditText) findViewById(R.id.password_edit_text);</span><br><span class="line">        loginButton = (Button) findViewById(R.id.login_button);</span><br><span class="line"></span><br><span class="line">        loginButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                loginPresenter.validateCredentialsAndPerformLogin(</span><br><span class="line">                        usernameEditText.getText().toString(),</span><br><span class="line">                        passwordEditText.getText().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showLoginSuccessMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;Login Success&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showLoginFailedMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;Login Failed&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showLoginAttemptExceededMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;Login Attempt Exceeded&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的Presenter实现如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginPresenter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LoginView loginView;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loginAttempt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginPresenter</span><span class="params">(LoginView loginView)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginView = loginView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validateCredentialsAndPerformLogin</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLoginAttemptExceeded()) &#123;</span><br><span class="line">            loginView.showLoginAttemptExceededMessage();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        incrementLoginAttempt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (username.equals(<span class="string">&quot;admin&quot;</span>) &amp;&amp; password.equals(<span class="string">&quot;admin&quot;</span>)) &#123;</span><br><span class="line">            loginView.showLoginSuccessMessage();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            loginView.showLoginFailedMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">incrementLoginAttempt</span><span class="params">()</span> &#123;</span><br><span class="line">        loginAttempt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLoginAttemptExceeded</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loginAttempt &gt;= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您将在LoginPresenterTest中发生错误，因为我们有构建使用LoginView对象的Presenter的构造函数。<br><img src="https://cdn-images-1.medium.com/max/800/1*MCKwoXItQiLJzYc9_z3qjQ.png" alt="错误"><br>为了摆脱这个错误，我们必须在创建演示者对象时将LoginView的对象传递给Presenter。 所以我们必须模拟LoginView.Here来模仿😍。</p>
<h3 id="什么是模仿？"><a href="#什么是模仿？" class="headerlink" title="什么是模仿？"></a>什么是模仿？</h3><p>你有一个对象，你想要测试的方法，这些方法都依赖于其他对象。 您创建依赖对象的模拟，而不是创建该依赖关系的实际实例。 模拟对象用于单元测试。</p>
<p>为了模仿，我们将使用Mockito。<br>将以下testCompile依赖项添加到应用程序的build.gradle</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">testCompile <span class="string">&#x27;org.mockito:mockito-core:1.10.19&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在我们模仿我们的LoginView，如下所示</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*CqN7YriY3D7NVkkXV2TZ-g.png" alt="模仿"></p>
<p>Ooho😳，😎我们有我们的模拟（神奇）登录对象，可以传递给Presenter。 所以我们的实现就像下图</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*JO-0qh-ZMd8XONeOBtYZmg.png" alt="通过测试"></p>
<p>运行测试显示绿色信号继续。</p>
<h3 id="集成测试（Presenter和View之间）"><a href="#集成测试（Presenter和View之间）" class="headerlink" title="集成测试（Presenter和View之间）"></a>集成测试（Presenter和View之间）</h3><p>要验证Presenter调用正确的View方法后，我们使用verify（）。<br><img src="https://cdn-images-1.medium.com/max/800/1*O5FxqfH3kFGp9qVtq3U_2g.png" alt="验证"><br>在上面的代码图中，验证方法确保在视图对象上调用showLoginSuccessMessage（），这确保我们的Presenter正确地与View集成。</p>
<p>其他测试如下</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*3xwuV6prCaZ2kImWZzdLpg.png" alt="验证"></p>
<p>End</p>
<p>同时，希望听到有关这方面的建议和意见。</p>
<p>干杯🍻!!! </p>
]]></content>
      <categories>
        <category>Android测试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>译文</tag>
        <tag>TDD</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>雪山来信</title>
    <url>/2024/12/18/%E9%9B%AA%E5%B1%B1%E6%9D%A5%E4%BF%A1/</url>
    <content><![CDATA[<p><img src="https://images.unsplash.com/photo-1735776327649-eeb6b6ed8829?q=80&w=1974&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA==" alt="雪山来信"></p>
<p>远方的雪山在夕阳下泛着金红色的光芒，我坐在草原上，听着耳机里流淌的钢琴曲。<br>这是第三十七次收到她的来信，信封上依然是那个熟悉的地址：<br>喜马拉雅山脉，海拔6500米，第四号营地。</p>
<p>没有人知道她为什么会在那里，就像没有人知道为什么高山上会有邮局。<br>但这些信，确实每个月都会准时出现在我的邮箱里，带着雪山的气息和一丝若有若无的檀香。</p>
<span id="more"></span>

<p>第一封信到来的时候，我刚刚结束一段失败的感情。<br>那时我以为，这或许是某个朋友的恶作剧，又或是命运开的一个玩笑。<br>信中只有简单的几句话：”在这里，星星很近，近到伸手就能触碰。有时我会想，如果用力跳起来，是不是就能抓住一颗带回给你。”</p>
<p>随后的信件里，她告诉我关于雪山的故事。<br>关于凌晨四点出发时踩在积雪上的咯吱声，关于风在氧气面罩上结出的冰晶，关于在极限海拔时每一次呼吸都像是在和死神搏斗。<br>她从不提及为什么去那里，也不说何时会回来。</p>
<p>“今天看到一只雪豹，”她在第十二封信中写道，”它就站在离我二十米的地方，金色的眼睛里倒映着整个雪山。那一刻我明白了，有些美好，注定是孤独的。”</p>
<p>我试图回信，但所有的信件都被退回，邮戳上盖着”地址不存在”的印章。<br>第三十七封信里，她写道：”明天将是最后一次攀登。在这里，时间是静止的，而我却在不断地坠落。也许每个人心中都有一座需要攀登的雪山，我的雪山就是你。再见了，我亲爱的陌生人。”<br>这是最后一封信。此后再也没有信件从那个不存在的地址寄来。</p>
<p>有时我会想，也许她真的存在，也许她真的在那座雪山上。<br>又或者，她只是我在某个寂寞时刻虚构出来的影子，是我内心深处对于未知的渴望和恐惧的投射。<br>但这些都不重要了。重要的是，在那些信件里，在那座可能并不存在的雪山上，有人用她的方式，完成了一场关于爱与孤独的朝圣。</p>
<p>夕阳最后的余晖也消失了，草原上升起了薄雾。<br>我摘下耳机，远处的雪山在暮色中若隐若现，像是一个模糊的梦境。<br>耳边似乎传来了雪落的声音，那么轻，那么远，仿佛是从另一个世界飘来的絮语。</p>
<p>《给雪山上的你》</p>
<p>我站在草原尽头<br>仰望那座金色的雪山<br>风掠过耳际<br>带来你遥远的呼吸声</p>
<p>星星藏在你的眼睛里<br>每一次眨眼<br>都有流星坠落<br>砸在我心底最柔软的地方</p>
<p>你说孤独是一种信仰<br>而我的信仰<br>是在每个黄昏<br>数着你寄来的信封</p>
<p>雪豹走过的路径上<br>落下你的脚印<br>我收集每一片雪花<br>都是你未说完的话语</p>
<p>六千五百米的距离<br>不及心与心之间<br>那道无法跨越的沟壑<br>深不见底</p>
<p>但我依然固执地相信<br>在某个清晨<br>推开窗，你会像初雪一样<br>悄无声息地落在我的掌心</p>
<p>即使知道<br>你可能只是<br>我在寂寞时刻<br>编织的一场大梦</p>
]]></content>
      <categories>
        <category>短篇小说</category>
      </categories>
      <tags>
        <tag>AI短篇小说</tag>
        <tag>AI生成</tag>
      </tags>
  </entry>
</search>
